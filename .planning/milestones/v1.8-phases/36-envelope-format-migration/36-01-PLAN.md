---
phase: 36-envelope-format-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/src/envelope.rs
autonomous: true
requirements: [ENV-01, ENV-02, ENV-03, VER-01]

must_haves:
  truths:
    - "seal() derives the AES-256-GCM encryption key exactly once per envelope via HKDF-Extract + Expand, not once per chunk"
    - "Per-chunk nonces are deterministic counters (8-byte prefix || 3-byte chunk_index BE || 1-byte last_flag), not random"
    - "Envelope struct carries version: u8 and hkdf_salt: [u8; 32] as top-level serde fields"
    - "New envelopes are always version 2"
  artifacts:
    - path: "crates/core/src/envelope.rs"
      provides: "v2 envelope seal path with HKDF-once key derivation and deterministic nonces"
      contains: "version: u8"
  key_links:
    - from: "Envelope::seal"
      to: "derive_shared_encryption_key"
      via: "called once before chunk loop, returns 40 bytes (32 key + 8 nonce prefix)"
      pattern: "hkdf.expand.*40"
    - from: "Envelope::create_encrypted_chunk"
      to: "nonce construction"
      via: "deterministic counter from nonce_prefix + chunk_index + last_flag"
      pattern: "nonce_prefix"
---

<objective>
Rewrite the envelope seal path to use HKDF-once key derivation with deterministic counter nonces and add version/salt fields to the Envelope struct.

Purpose: Eliminate the per-chunk random salt + HKDF derivation, replacing it with a single HKDF call that produces both the encryption key and a nonce prefix. Each chunk's nonce is then a deterministic counter, making the scheme correct (one key derivation per ECDH agreement) and auditable.

Output: envelope.rs with v2 seal path producing versioned envelopes with deterministic nonces. Existing tests will temporarily break (expected — Plan 02 restores them by adding the v1 fallback decrypt path).
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-hkdf-infrastructure/35-01-SUMMARY.md
@crates/core/src/envelope.rs
@crates/core/src/format.rs
@crates/core/src/lib.rs (for NetworkChunk struct)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add version and hkdf_salt fields to Envelope struct, restructure derive function</name>
  <files>crates/core/src/envelope.rs</files>
  <action>
  Modify the Envelope struct to add two new top-level fields:

  1. `version: u8` — Add `#[serde(default = "default_envelope_version")]` where `default_envelope_version()` returns `1u8`. This ensures deserialization of old v1 envelopes (which lack the field) defaults to version 1.

  2. `hkdf_salt: [u8; 32]` — Add `#[serde(default)]` so old envelopes deserialize with `[0u8; 32]`.

  Add the helper function `fn default_envelope_version() -> u8 { 1 }`.

  Rewrite `derive_shared_encryption_key()` to:
  - Remove the unused parameters: `_sequence`, `_metadata_hash`, `_iterations`
  - New signature: `fn derive_shared_encryption_key(my_private_key: &SigningKey, their_public_key: &VerifyingKey, salt: &[u8; 32]) -> Result<([u8; 32], [u8; 8])>`
  - Return type is a tuple: (encryption_key, nonce_prefix)
  - ECDH + zero-check remains the same
  - HKDF-Extract with `salt` parameter and ECDH shared secret as IKM remains the same
  - HKDF-Expand changes: expand into a 40-byte buffer with info `b"TRUSTEDGE_ENVELOPE_V1"`, then split: bytes 0..32 = encryption key, bytes 32..40 = nonce prefix
  - Zeroize the 40-byte OKM buffer after splitting
  - Return `Ok((encryption_key, nonce_prefix))`
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/trustedge && cargo check -p trustedge-core 2>&1 | tail -20</automated>
    <manual>Envelope struct has version and hkdf_salt fields; derive function returns (key, prefix) tuple</manual>
  </verify>
  <done>Envelope struct has version: u8 and hkdf_salt: [u8; 32] with serde defaults; derive_shared_encryption_key returns 40-byte OKM split into (key, nonce_prefix); cargo check passes</done>
</task>

<task type="auto">
  <name>Task 2: Implement v2 seal path with single HKDF derivation and deterministic nonces</name>
  <files>crates/core/src/envelope.rs</files>
  <action>
  Rewrite `Envelope::seal()` to implement the v2 envelope format:

  1. **Generate per-envelope salt:** Generate a random 32-byte `hkdf_salt` once (using `rand::thread_rng().fill_bytes()`), stored on the Envelope struct.

  2. **Derive key material once:** Call `derive_shared_encryption_key(signing_key, beneficiary_key, &hkdf_salt)` ONCE before the chunk loop. This returns `(encryption_key, nonce_prefix)`.

  3. **Set version to 2:** The Envelope constructor sets `version: 2u8`.

  4. **Rewrite `create_encrypted_chunk()`** — change signature to accept `encryption_key: &[u8; 32]`, `nonce_prefix: &[u8; 8]`, and `is_last_chunk: bool` instead of generating its own salt/nonce. Remove `signing_key` and `beneficiary_key` from parameters since key derivation is done at seal level.

  5. **Deterministic nonce construction** inside `create_encrypted_chunk()`:
     - Build 12-byte nonce: copy `nonce_prefix` (8 bytes) into positions 0..8, encode `sequence as u32` (use the low 3 bytes only: `(sequence as u32).to_be_bytes()[1..4]`) into positions 8..11, set position 11 to `if is_last_chunk { 0xFF } else { 0x00 }`.
     - This supports up to 16M chunks (3 bytes = 16,777,216).

  6. **ChunkManifest v2 values:** Set `key_derivation_salt: [0u8; 32]` and `pbkdf2_iterations: 0u32` (zeroed out per decision — fields kept for serde compat).

  7. **The chunk's nonce field** (on NetworkChunk) is populated with the computed deterministic nonce — consistent with v1 layout and useful for debugging.

  8. **Zeroize** the encryption key after the chunk loop completes (move zeroize from per-chunk to per-envelope level).

  The seal function flow becomes:
  ```
  generate hkdf_salt (random 32 bytes)
  (key, nonce_prefix) = derive_shared_encryption_key(...)
  for each chunk:
      nonce = nonce_prefix || chunk_index[1..4] || last_flag
      encrypt chunk with (key, nonce)
      set ChunkManifest.key_derivation_salt = [0; 32]
      set ChunkManifest.pbkdf2_iterations = 0
  zeroize(key)
  Envelope { version: 2, hkdf_salt, chunks, ... }
  ```

  Do NOT touch the decrypt path yet (Plan 02 handles that).
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/trustedge && cargo check -p trustedge-core 2>&1 | tail -20</automated>
    <manual>seal() calls derive once before loop, create_encrypted_chunk uses deterministic nonce, ChunkManifest fields zeroed in v2</manual>
  </verify>
  <done>seal() derives key once via HKDF, chunks use deterministic counter nonces (prefix||index||last_flag), version=2, hkdf_salt stored on envelope, ChunkManifest salt/iterations zeroed. cargo check passes (tests may fail until Plan 02 updates decrypt path)</done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo check -p trustedge-core` compiles clean (no errors)
2. Envelope struct has `version: u8` and `hkdf_salt: [u8; 32]` with proper serde defaults
3. `derive_shared_encryption_key` returns `([u8; 32], [u8; 8])` — 32-byte key + 8-byte nonce prefix
4. `seal()` generates one salt, calls derive once, then loops over chunks with deterministic nonces
5. Nonce layout: 8 prefix + 3 chunk_index (BE) + 1 last_flag = 12 bytes total
6. ChunkManifest in v2 has zeroed `key_derivation_salt` and `pbkdf2_iterations`
</verification>

<success_criteria>
- Envelope struct has version and hkdf_salt fields with serde backward compat
- HKDF derivation happens exactly once per seal() call, producing 40-byte OKM
- Nonce construction is deterministic: prefix || chunk_index || last_flag
- `cargo check -p trustedge-core` passes
- ENV-01, ENV-02, ENV-03, VER-01 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/36-envelope-format-migration/36-01-SUMMARY.md`
</output>
