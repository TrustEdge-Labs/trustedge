---
phase: 34-platform-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/platform/src/http/router.rs
  - crates/platform/src/http/handlers.rs
  - crates/platform/tests/verify_integration.rs
autonomous: true
requirements: [TST-02, TST-03]

must_haves:
  truths:
    - "create_test_app (postgres variant) uses create_router internally so middleware is identical to production"
    - "An OPTIONS preflight request returns the same CORS headers from both the test app and create_router output"
    - "A correctly signed payload submitted to /v1/verify returns HTTP 200 with a JWS receipt"
    - "The JWS receipt can be decoded and its Ed25519 signature verified against the JWKS endpoint"
  artifacts:
    - path: "crates/platform/src/http/router.rs"
      provides: "Shared router builder called by both create_router and create_test_app"
      contains: "fn build_base_router"
    - path: "crates/platform/tests/verify_integration.rs"
      provides: "Full round-trip and CORS parity tests"
      min_lines: 100
  key_links:
    - from: "crates/platform/src/http/handlers.rs"
      to: "crates/platform/src/http/router.rs"
      via: "create_test_app calls create_router instead of duplicating routes"
      pattern: "create_router"
    - from: "crates/platform/tests/verify_integration.rs"
      to: "/v1/verify endpoint"
      via: "HTTP POST with signed payload, then JWS decode + JWKS verify"
      pattern: "test_verify_round_trip"
---

<objective>
Extract a shared router builder so `create_test_app` mirrors `create_router` exactly, add a CORS parity test, and implement the full HTTP verify round-trip test with receipt JWS verification against the JWKS endpoint.

Purpose: TST-02 ensures middleware fidelity between test and production routers. TST-03 validates the complete sign-then-verify pipeline over HTTP — the most critical integration test for the platform.

Output: Refactored router.rs with shared builder, updated create_test_app in handlers.rs, and 4+ new tests in verify_integration.rs.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/platform/src/http/router.rs
@crates/platform/src/http/handlers.rs
@crates/platform/src/http/state.rs
@crates/platform/src/http/config.rs
@crates/platform/src/http/auth.rs
@crates/platform/src/verify/engine.rs
@crates/platform/src/verify/signing.rs
@crates/platform/src/verify/jwks.rs
@crates/platform/src/verify/types.rs
@crates/platform/tests/verify_integration.rs
@crates/platform/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared router builder and refactor create_test_app</name>
  <files>
    crates/platform/src/http/router.rs
    crates/platform/src/http/handlers.rs
  </files>
  <action>
**Goal:** Make `create_test_app` (the postgres-gated test utility in handlers.rs) call `create_router` instead of manually duplicating routes. This ensures middleware parity (TST-02).

**Step 1: Refactor create_test_app in handlers.rs**

The current `create_test_app` in handlers.rs (lines 362-382) manually constructs routes and applies auth middleware but does NOT apply CORS or TraceLayer. This is the fidelity gap TST-02 targets.

Replace the `create_test_app` function body to delegate to `create_router`:

```rust
#[cfg(all(any(test, feature = "test-utils"), feature = "postgres"))]
pub fn create_test_app(pool: sqlx::PgPool) -> axum::Router {
    let keys = std::sync::Arc::new(tokio::sync::RwLock::new(
        crate::verify::jwks::KeyManager::new().expect("KeyManager should initialize for test"),
    ));
    let state = AppState {
        db_pool: pool,
        keys,
    };
    crate::http::create_router(state)
}
```

This is a drop-in replacement. The `create_router` function already:
- Adds all routes (verify, devices, receipts, jwks, health)
- Applies auth middleware (when postgres feature is enabled)
- Applies CORS layer
- Applies TraceLayer

The old create_test_app was missing CORS and TraceLayer. Now they match exactly.

**Step 2: No changes needed to router.rs for this task**

The `create_router` function already encapsulates the full middleware stack. The "shared builder" concept from user decisions is satisfied by having create_test_app call create_router directly — no intermediate builder function extraction is needed because create_router IS the single source of truth.

If an intermediate `build_base_router` function would be cleaner, you may extract the non-postgres portion (the 3 base routes) into a helper, but this is Claude's discretion. The key requirement is that create_test_app goes through create_router.
  </action>
  <verify>
```bash
# Verify compilation with postgres feature (create_test_app is postgres-gated)
cargo build -p trustedge-platform --features "http,postgres"

# Verify compilation without postgres (non-postgres code path)
cargo build -p trustedge-platform --features http

# Clippy for both variants
cargo clippy -p trustedge-platform --features "http,postgres" -- -D warnings
cargo clippy -p trustedge-platform --features http -- -D warnings

# Existing tests still pass
cargo test -p trustedge-platform --test verify_integration --features http
```
  </verify>
  <done>
`create_test_app` delegates to `create_router` — identical middleware stack. Compiles and passes clippy under both feature combinations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CORS parity test and full verify round-trip tests</name>
  <files>
    crates/platform/tests/verify_integration.rs
  </files>
  <action>
Add new tests to the existing `http_tests` module in `verify_integration.rs` (which is gated with `#[cfg(all(feature = "http", not(feature = "postgres")))]`).

The existing `create_test_app()` function in this module already calls `create_router(state)` — it is already faithful for the non-postgres variant. New tests exercise the verify endpoint end-to-end.

**Test 1: `test_cors_preflight_deny` (CORS parity for verify-only)**

Send an OPTIONS preflight request to `/v1/verify` with `Origin: http://evil.example.com`. Assert the response does NOT include `Access-Control-Allow-Origin` header (because verify-only uses `CorsLayer::new()` which denies all cross-origin). This confirms the CORS policy is applied correctly.

```rust
#[tokio::test]
async fn test_cors_preflight_deny() -> Result<()> {
    let app = create_test_app().await;
    let response = app
        .oneshot(
            Request::builder()
                .method("OPTIONS")
                .uri("/v1/verify")
                .header("Origin", "http://evil.example.com")
                .header("Access-Control-Request-Method", "POST")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();
    // CorsLayer::new() does not add ACAO header for unknown origins
    assert!(response.headers().get("access-control-allow-origin").is_none());
    Ok(())
}
```

**Test 2: `test_verify_round_trip` (TST-03 happy path)**

Full sign-then-verify pipeline:
1. Generate a random Ed25519 signing key using `SigningKey::generate(&mut rand::rngs::OsRng)`
2. Create a manifest JSON with version, segments count, device_id
3. Canonicalize manifest (serialize without signature field), sign with Ed25519
4. Add base64-encoded signature to manifest
5. Create segment digests with valid `b3:<64 hex chars>` format
6. Build a `VerifyRequest` JSON with `device_pub: "ed25519:<base64 verifying key>"`, signed manifest, segments, and `options: { return_receipt: true, device_id: "test-device" }`
7. POST to `/v1/verify` as JSON
8. Assert HTTP 200
9. Parse response JSON as `VerifyResponse`
10. Assert `result.signature_verification.passed == true`
11. Assert `result.continuity_verification.passed == true`
12. Assert `receipt` is `Some` (non-null string)
13. Assert `verification_id` starts with "v_"

```rust
#[tokio::test]
async fn test_verify_round_trip() -> Result<()> {
    // ... (see above for structure)
}
```

Use `serde_json::json!` to build the request body. The segment hashes must be valid hex format: `b3:` followed by exactly 64 lowercase hex characters. Use a fixed known-good hash like `"b3:1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"`.

**Test 3: `test_verify_receipt_matches_jwks` (TST-03 receipt verification)**

Same setup as test_verify_round_trip but additionally:
1. After getting the receipt JWS from the verify response, also GET `/.well-known/jwks.json`
   - Note: Since `oneshot` consumes the router, you need to build TWO routers (both from the same KeyManager/AppState). Instead, build the AppState once, clone it, and create two routers. OR reconstruct the app for the second request.
   - Simpler approach: Use a shared `AppState` and construct two separate routers from it (AppState is Clone).
2. Parse JWKS response to extract the Ed25519 public key (`x` field, base64 decoded)
3. Parse the JWS receipt: split by `.`, base64url-decode the header and payload
4. Verify the JWS header has `"alg": "EdDSA"` and `"kid"` matches a key in JWKS
5. Verify the receipt payload contains `device_id`, `manifest_digest`, `chain_tip`
6. Reconstruct the signing input (`header.payload` in base64url), decode the signature part, and verify the Ed25519 signature against the JWKS public key using `ed25519_dalek::VerifyingKey::verify_strict`

For the Ed25519 verification of the JWS:
- The JWS format is `base64url(header).base64url(payload).base64url(signature)`
- The signing input is the bytes of `base64url(header).base64url(payload)` (the first two parts joined with `.`)
- Decode the signature from base64url, construct an `ed25519_dalek::Signature` from the 64 bytes
- Get the verifying key from JWKS `x` field (base64 standard decode to 32 bytes), construct `VerifyingKey::from_bytes`
- Call `verifying_key.verify_strict(signing_input_bytes, &signature)` — should succeed

```rust
#[tokio::test]
async fn test_verify_receipt_matches_jwks() -> Result<()> {
    // Build shared state
    let key_manager = KeyManager::new().unwrap();
    let state = AppState {
        keys: Arc::new(RwLock::new(key_manager)),
    };

    // First request: POST /v1/verify
    let app1 = create_router(state.clone());
    // ... send verify request, get receipt JWS ...

    // Second request: GET /.well-known/jwks.json
    let app2 = create_router(state);
    // ... get JWKS, extract public key ...

    // Verify JWS signature against JWKS key
    // ... decode JWS parts, verify Ed25519 signature ...
    Ok(())
}
```

**Test 4: `test_verify_wrong_key_returns_failed_signature` (negative case)**

Sign a manifest with one key but provide a DIFFERENT key's public key in `device_pub`. Assert HTTP 200 (server returns result, not error), but `result.signature_verification.passed == false` and receipt is `None`.

**Additional imports needed at the top of the http_tests module:**
- `use axum::http::header::CONTENT_TYPE;` (for POST requests)
- `use ed25519_dalek::{Signer, Verifier, VerifyingKey as DalekVerifyingKey};` (for JWS verification)
- `use base64::engine::general_purpose::URL_SAFE_NO_PAD as BASE64URL;` (for JWS decoding)

Note: `ed25519_dalek` is already in platform's dev-dependencies. `base64` is already in platform's dependencies.
  </action>
  <verify>
```bash
# Run all verify integration tests (both pure crypto and HTTP)
cargo test -p trustedge-platform --test verify_integration --features http -- --nocapture

# Count tests — should be original 7 + 4 new = 11
cargo test -p trustedge-platform --test verify_integration --features http -- --list 2>&1 | tail -1

# Clippy clean
cargo clippy -p trustedge-platform --features http --tests -- -D warnings
```
  </verify>
  <done>
4 new tests in verify_integration.rs: CORS preflight denied, full round-trip with receipt, receipt JWS verified against JWKS, wrong-key signature failure. Total integration test count reaches 11.
  </done>
</task>

</tasks>

<verification>
```bash
# All verify integration tests pass (including new round-trip tests)
cargo test -p trustedge-platform --test verify_integration --features http

# Pure crypto tests still pass
cargo test -p trustedge-platform --test verify_integration

# create_test_app compiles with postgres
cargo build -p trustedge-platform --features "http,postgres"

# Clippy clean across all feature combos
cargo clippy -p trustedge-platform --features http --tests -- -D warnings
cargo clippy -p trustedge-platform --features "http,postgres" --tests -- -D warnings

# Full CI check
./scripts/ci-check.sh
```
</verification>

<success_criteria>
- `create_test_app` (postgres) delegates to `create_router` — no duplicated route definitions
- CORS parity test confirms verify-only build denies cross-origin preflight
- `test_verify_round_trip` sends a signed payload and receives HTTP 200 with receipt
- `test_verify_receipt_matches_jwks` decodes the JWS receipt and verifies the Ed25519 signature against the JWKS public key
- `test_verify_wrong_key_returns_failed_signature` confirms signature failure for mismatched keys
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-platform-testing/34-02-SUMMARY.md`
</output>
