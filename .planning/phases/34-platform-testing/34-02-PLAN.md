---
phase: 34-platform-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/platform/src/http/router.rs
  - crates/platform/src/http/mod.rs
  - crates/platform/src/http/handlers.rs
  - crates/platform/tests/verify_integration.rs
autonomous: true
requirements: [TST-02, TST-03]

must_haves:
  truths:
    - "create_test_app (postgres variant) uses create_router internally so middleware is identical to production"
    - "An OPTIONS preflight request sent to two independently constructed routers returns identical CORS headers, proving build_base_router -> create_router parity"
    - "A correctly signed payload submitted to /v1/verify returns HTTP 200 with a JWS receipt"
    - "The JWS receipt can be decoded and its Ed25519 signature verified against the JWKS endpoint"
  artifacts:
    - path: "crates/platform/src/http/router.rs"
      provides: "Shared router builder called by both create_router and create_test_app"
      contains: "fn build_base_router"
    - path: "crates/platform/tests/verify_integration.rs"
      provides: "Full round-trip and CORS parity tests"
      min_lines: 100
  key_links:
    - from: "crates/platform/src/http/router.rs"
      to: "crates/platform/src/http/handlers.rs"
      via: "create_router calls build_base_router; create_test_app calls create_router"
      pattern: "build_base_router"
    - from: "crates/platform/tests/verify_integration.rs"
      to: "/v1/verify endpoint"
      via: "HTTP POST with signed payload, then JWS decode + JWKS verify"
      pattern: "test_verify_round_trip"
---

<objective>
Extract a shared router builder so `create_test_app` mirrors `create_router` exactly, add a CORS parity test, and implement the full HTTP verify round-trip test with receipt JWS verification against the JWKS endpoint.

Purpose: TST-02 ensures middleware fidelity between test and production routers. TST-03 validates the complete sign-then-verify pipeline over HTTP — the most critical integration test for the platform.

Output: Refactored router.rs with shared builder, updated create_test_app in handlers.rs, and 4+ new tests in verify_integration.rs.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/platform/src/http/router.rs
@crates/platform/src/http/handlers.rs
@crates/platform/src/http/state.rs
@crates/platform/src/http/config.rs
@crates/platform/src/http/auth.rs
@crates/platform/src/verify/engine.rs
@crates/platform/src/verify/signing.rs
@crates/platform/src/verify/jwks.rs
@crates/platform/src/verify/types.rs
@crates/platform/tests/verify_integration.rs
@crates/platform/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared router builder and refactor create_test_app</name>
  <files>
    crates/platform/src/http/router.rs
    crates/platform/src/http/mod.rs
    crates/platform/src/http/handlers.rs
  </files>
  <action>
**Goal:** Extract a shared `build_base_router` function that both `create_router` and `create_test_app` call, then make `create_test_app` delegate to `create_router`. This ensures middleware parity (TST-02) via a single source of truth for the middleware stack.

**Step 1: Extract `build_base_router` in router.rs**

Extract the three base routes (verify, jwks, health) into a new public helper function:

```rust
/// Build the base router with routes shared across all feature configurations.
/// Both `create_router` and `create_test_app` ultimately call this.
pub fn build_base_router() -> Router<AppState> {
    Router::new()
        .route("/v1/verify", post(verify_handler))
        .route("/.well-known/jwks.json", get(jwks_handler))
        .route("/healthz", get(health_handler))
}
```

Then refactor `create_router` to call `build_base_router()` instead of constructing the base routes inline:

```rust
pub fn create_router(state: AppState) -> Router {
    let base = build_base_router();

    #[cfg(feature = "postgres")]
    let base = {
        // ... existing postgres additions (device, receipt routes, auth middleware, CORS, TraceLayer) ...
    };

    #[cfg(not(feature = "postgres"))]
    let base = base
        .with_state(state)
        .layer(CorsLayer::new())
        .layer(TraceLayer::new_for_http());

    base
}
```

This is a refactor only — behavior unchanged, but now the route set is defined in exactly one place.

Also add `build_base_router` to the re-exports in `crates/platform/src/http/mod.rs`:
```rust
pub use router::{build_base_router, create_router};
```

**Step 2: Refactor create_test_app in handlers.rs**

The current `create_test_app` in handlers.rs manually constructs routes and applies auth middleware but does NOT apply CORS or TraceLayer. This is the fidelity gap TST-02 targets.

Replace the `create_test_app` function body to delegate to `create_router`:

```rust
#[cfg(all(any(test, feature = "test-utils"), feature = "postgres"))]
pub fn create_test_app(pool: sqlx::PgPool) -> axum::Router {
    let keys = std::sync::Arc::new(tokio::sync::RwLock::new(
        crate::verify::jwks::KeyManager::new().expect("KeyManager should initialize for test"),
    ));
    let state = AppState {
        db_pool: pool,
        keys,
    };
    crate::http::create_router(state)
}
```

This is a drop-in replacement. `create_router` now calls `build_base_router()` internally, and applies the full middleware stack (CORS, TraceLayer, auth if postgres). The old `create_test_app` was missing CORS and TraceLayer. Now both paths share the same route set and middleware stack via the `build_base_router` -> `create_router` chain.
  </action>
  <verify>
```bash
# Verify compilation with postgres feature (create_test_app is postgres-gated)
cargo build -p trustedge-platform --features "http,postgres"

# Verify compilation without postgres (non-postgres code path)
cargo build -p trustedge-platform --features http

# Clippy for both variants
cargo clippy -p trustedge-platform --features "http,postgres" -- -D warnings
cargo clippy -p trustedge-platform --features http -- -D warnings

# Existing tests still pass
cargo test -p trustedge-platform --test verify_integration --features http
```
  </verify>
  <done>
`create_test_app` delegates to `create_router` — identical middleware stack. Compiles and passes clippy under both feature combinations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CORS parity test and full verify round-trip tests</name>
  <files>
    crates/platform/tests/verify_integration.rs
  </files>
  <action>
Add new tests to the existing `http_tests` module in `verify_integration.rs` (which is gated with `#[cfg(all(feature = "http", not(feature = "postgres")))]`).

The existing `create_test_app()` function in this module already calls `create_router(state)` — it is already faithful for the non-postgres variant. New tests exercise the verify endpoint end-to-end.

**Test 1: `test_cors_preflight_parity` (CORS parity between two router instances)**

Build TWO routers from `create_router` (using the same AppState, cloned) to prove they produce identical CORS behavior. Send an OPTIONS preflight request with `Origin: http://evil.example.com` to `/v1/verify` on BOTH routers. Collect the CORS-related response headers from each (`access-control-allow-origin`, `access-control-allow-methods`, `access-control-allow-headers`) and assert they are identical between the two responses. For verify-only mode, both should DENY the origin (no `Access-Control-Allow-Origin` header present).

This directly validates the user decision: "send OPTIONS preflight to both create_test_app and create_router outputs, assert identical headers." In non-postgres mode, both paths go through `create_router`, and this test proves two independent router constructions from the same `build_base_router` -> `create_router` chain produce byte-identical CORS responses.

```rust
#[tokio::test]
async fn test_cors_preflight_parity() -> Result<()> {
    // Build two independent routers from the same AppState
    let key_manager = KeyManager::new()?;
    let state = AppState {
        keys: Arc::new(RwLock::new(key_manager)),
    };
    let app1 = create_router(state.clone());
    let app2 = create_router(state);

    let preflight = || {
        Request::builder()
            .method("OPTIONS")
            .uri("/v1/verify")
            .header("Origin", "http://evil.example.com")
            .header("Access-Control-Request-Method", "POST")
            .body(Body::empty())
            .unwrap()
    };

    let resp1 = app1.oneshot(preflight()).await.unwrap();
    let resp2 = app2.oneshot(preflight()).await.unwrap();

    // Assert identical CORS headers (both should deny the origin)
    assert_eq!(
        resp1.headers().get("access-control-allow-origin"),
        resp2.headers().get("access-control-allow-origin"),
    );
    assert_eq!(
        resp1.headers().get("access-control-allow-methods"),
        resp2.headers().get("access-control-allow-methods"),
    );
    assert_eq!(
        resp1.headers().get("access-control-allow-headers"),
        resp2.headers().get("access-control-allow-headers"),
    );
    // Verify-only: CorsLayer::new() denies all cross-origin
    assert!(resp1.headers().get("access-control-allow-origin").is_none());
    Ok(())
}
```

**Test 2: `test_verify_round_trip` (TST-03 happy path)**

Full sign-then-verify pipeline:
1. Generate a random Ed25519 signing key using `SigningKey::generate(&mut rand::rngs::OsRng)`
2. Create a manifest JSON with version, segments count, device_id
3. Canonicalize manifest (serialize without signature field), sign with Ed25519
4. Add base64-encoded signature to manifest
5. Create segment digests with valid `b3:<64 hex chars>` format
6. Build a `VerifyRequest` JSON with `device_pub: "ed25519:<base64 verifying key>"`, signed manifest, segments, and `options: { return_receipt: true, device_id: "test-device" }`
7. POST to `/v1/verify` as JSON
8. Assert HTTP 200
9. Parse response JSON as `VerifyResponse`
10. Assert `result.signature_verification.passed == true`
11. Assert `result.continuity_verification.passed == true`
12. Assert `receipt` is `Some` (non-null string)
13. Assert `verification_id` starts with "v_"

```rust
#[tokio::test]
async fn test_verify_round_trip() -> Result<()> {
    // ... (see above for structure)
}
```

Use `serde_json::json!` to build the request body. The segment hashes must be valid hex format: `b3:` followed by exactly 64 lowercase hex characters. Use a fixed known-good hash like `"b3:1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"`.

**Test 3: `test_verify_receipt_matches_jwks` (TST-03 receipt verification)**

Same setup as test_verify_round_trip but additionally:
1. After getting the receipt JWS from the verify response, also GET `/.well-known/jwks.json`
   - Note: Since `oneshot` consumes the router, you need to build TWO routers (both from the same KeyManager/AppState). Instead, build the AppState once, clone it, and create two routers. OR reconstruct the app for the second request.
   - Simpler approach: Use a shared `AppState` and construct two separate routers from it (AppState is Clone).
2. Parse JWKS response to extract the Ed25519 public key (`x` field, base64 decoded)
3. Parse the JWS receipt: split by `.`, base64url-decode the header and payload
4. Verify the JWS header has `"alg": "EdDSA"` and `"kid"` matches a key in JWKS
5. Verify the receipt payload contains `device_id`, `manifest_digest`, `chain_tip`
6. Reconstruct the signing input (`header.payload` in base64url), decode the signature part, and verify the Ed25519 signature against the JWKS public key using `ed25519_dalek::VerifyingKey::verify_strict`

For the Ed25519 verification of the JWS:
- The JWS format is `base64url(header).base64url(payload).base64url(signature)`
- The signing input is the bytes of `base64url(header).base64url(payload)` (the first two parts joined with `.`)
- Decode the signature from base64url, construct an `ed25519_dalek::Signature` from the 64 bytes
- Get the verifying key from JWKS `x` field (base64 standard decode to 32 bytes), construct `VerifyingKey::from_bytes`
- Call `verifying_key.verify_strict(signing_input_bytes, &signature)` — should succeed

```rust
#[tokio::test]
async fn test_verify_receipt_matches_jwks() -> Result<()> {
    // Build shared state
    let key_manager = KeyManager::new().unwrap();
    let state = AppState {
        keys: Arc::new(RwLock::new(key_manager)),
    };

    // First request: POST /v1/verify
    let app1 = create_router(state.clone());
    // ... send verify request, get receipt JWS ...

    // Second request: GET /.well-known/jwks.json
    let app2 = create_router(state);
    // ... get JWKS, extract public key ...

    // Verify JWS signature against JWKS key
    // ... decode JWS parts, verify Ed25519 signature ...
    Ok(())
}
```

**Test 4: `test_verify_wrong_key_returns_failed_signature` (negative case)**

Sign a manifest with one key but provide a DIFFERENT key's public key in `device_pub`. Assert HTTP 200 (server returns result, not error), but `result.signature_verification.passed == false` and receipt is `None`.

**Additional imports needed at the top of the http_tests module:**
- `use axum::http::header::CONTENT_TYPE;` (for POST requests)
- `use ed25519_dalek::{Signer, Verifier, VerifyingKey as DalekVerifyingKey};` (for JWS verification)
- `use base64::engine::general_purpose::URL_SAFE_NO_PAD as BASE64URL;` (for JWS decoding)

Note: `ed25519_dalek` is already in platform's dev-dependencies. `base64` is already in platform's dependencies.
  </action>
  <verify>
```bash
# Run all verify integration tests (both pure crypto and HTTP)
cargo test -p trustedge-platform --test verify_integration --features http -- --nocapture

# Count tests — should be original 7 + 4 new = 11
cargo test -p trustedge-platform --test verify_integration --features http -- --list 2>&1 | tail -1

# Clippy clean
cargo clippy -p trustedge-platform --features http --tests -- -D warnings
```
  </verify>
  <done>
4 new tests in verify_integration.rs: CORS preflight parity (two routers, identical headers), full round-trip with receipt, receipt JWS verified against JWKS, wrong-key signature failure. Total integration test count reaches 11.
  </done>
</task>

</tasks>

<verification>
```bash
# All verify integration tests pass (including new round-trip tests)
cargo test -p trustedge-platform --test verify_integration --features http

# Pure crypto tests still pass
cargo test -p trustedge-platform --test verify_integration

# create_test_app compiles with postgres
cargo build -p trustedge-platform --features "http,postgres"

# Clippy clean across all feature combos
cargo clippy -p trustedge-platform --features http --tests -- -D warnings
cargo clippy -p trustedge-platform --features "http,postgres" --tests -- -D warnings

# Full CI check
./scripts/ci-check.sh
```
</verification>

<success_criteria>
- `create_test_app` (postgres) delegates to `create_router` — no duplicated route definitions
- CORS parity test sends OPTIONS to two independently constructed routers and asserts identical CORS response headers
- `test_verify_round_trip` sends a signed payload and receives HTTP 200 with receipt
- `test_verify_receipt_matches_jwks` decodes the JWS receipt and verifies the Ed25519 signature against the JWKS public key
- `test_verify_wrong_key_returns_failed_signature` confirms signature failure for mismatched keys
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-platform-testing/34-02-SUMMARY.md`
</output>
