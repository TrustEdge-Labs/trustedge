---
phase: 28-platform-server-binary
plan: 02
type: execute
wave: 2
depends_on:
  - 28-01
files_modified:
  - deploy/Dockerfile
  - deploy/docker-compose.yml
  - deploy/.env.example
autonomous: true
requirements:
  - PLAT-01
  - PLAT-02

must_haves:
  truths:
    - "A multi-stage Dockerfile builds the trustedge-platform-server binary from Rust source and produces a minimal debian-slim runtime image"
    - "docker-compose.yml starts postgres and platform-server together, with server depending on postgres health check"
    - ".env.example documents all configurable variables (PORT, DATABASE_URL, JWT_AUDIENCE) with explanatory comments"
  artifacts:
    - path: "deploy/Dockerfile"
      provides: "Multi-stage Docker build: rust builder + debian-slim runtime"
      contains: "FROM rust"
    - path: "deploy/docker-compose.yml"
      provides: "Compose file with postgres and trustedge-platform-server services"
      contains: "trustedge-platform-server"
    - path: "deploy/.env.example"
      provides: "Documented environment variable template for operators"
      contains: "DATABASE_URL"
  key_links:
    - from: "deploy/Dockerfile"
      to: "crates/platform-server"
      via: "cargo build -p trustedge-platform-server --release"
      pattern: "cargo build.*trustedge-platform-server"
    - from: "deploy/docker-compose.yml"
      to: "deploy/.env.example"
      via: "env_file reference or documented vars"
      pattern: "DATABASE_URL|JWT_AUDIENCE|PORT"
---

<objective>
Create deployment artifacts in `deploy/` — a multi-stage Dockerfile, docker-compose.yml (postgres + server), and .env.example with all variables documented.

Purpose: Operators need a clear, working path to deploy the platform server. These files make the binary deployable without understanding Rust toolchains.

Output: `deploy/Dockerfile`, `deploy/docker-compose.yml`, `deploy/.env.example`
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/28-platform-server-binary/28-CONTEXT.md
@.planning/phases/28-platform-server-binary/28-01-SUMMARY.md

User decisions (from CONTEXT.md):
- Multi-stage Dockerfile: builder compiles Rust, runtime is debian-slim
- docker-compose: postgres + platform-server backend only (no dashboard)
- All deployment artifacts in `deploy/` at repo root
- Dashboard runs natively with npm, not containerized
- Claude's discretion: exact base image (debian-slim vs alpine), postgres version, volume config
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deploy/Dockerfile (multi-stage Rust builder + debian-slim runtime)</name>
  <files>deploy/Dockerfile</files>
  <action>
Create `deploy/Dockerfile`. Use multi-stage build:

**Stage 1 — builder:**
- Base: `rust:1.82-slim` (or latest stable slim Rust image)
- Install `pkg-config` and `libssl-dev` (needed for sqlx TLS)
- Copy full workspace source: `COPY . .`
- Build release binary: `cargo build -p trustedge-platform-server --release`
- The binary will be at `/usr/src/app/target/release/trustedge-platform-server`

**Stage 2 — runtime:**
- Base: `debian:bookworm-slim`
- Install `ca-certificates` and `libssl3` (runtime TLS for sqlx postgres connections)
- Copy binary from builder: `COPY --from=builder /usr/src/app/target/release/trustedge-platform-server /usr/local/bin/`
- Set non-root user: `RUN useradd -r -s /bin/false trustedge` then `USER trustedge`
- `EXPOSE 3001`
- `CMD ["trustedge-platform-server", "serve"]`

Include a comment at the top: `# TrustEdge Platform Server — Multi-stage Docker build`

Note: Use WORKDIR `/usr/src/app` in the builder stage. Ensure `.dockerignore` considerations are noted in a comment (the file itself doesn't need to be created — that's optional infrastructure).
  </action>
  <verify>
`docker build -f deploy/Dockerfile -t trustedge-platform-server:test . 2>&1 | tail -5` — if Docker is available. If not, verify the file is syntactically correct by checking structure manually: `grep -n "FROM\|COPY\|RUN\|CMD\|EXPOSE\|USER" deploy/Dockerfile`
  </verify>
  <done>
`deploy/Dockerfile` exists with two FROM stages (rust builder + debian-slim runtime), copies the release binary, sets a non-root user, exposes port 3001, and defaults CMD to `trustedge-platform-server serve`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create deploy/docker-compose.yml and deploy/.env.example</name>
  <files>deploy/docker-compose.yml</files>
  <files>deploy/.env.example</files>
  <action>
**Create `deploy/docker-compose.yml`:**

```yaml
# TrustEdge Platform — Docker Compose (backend only)
# Dashboard runs natively: cd web/dashboard && npm run dev
#
# Usage:
#   cp deploy/.env.example deploy/.env
#   docker compose -f deploy/docker-compose.yml up

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: trustedge
      POSTGRES_PASSWORD: trustedge_dev
      POSTGRES_DB: trustedge
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U trustedge"]
      interval: 5s
      timeout: 5s
      retries: 5

  platform-server:
    build:
      context: ..
      dockerfile: deploy/Dockerfile
    env_file:
      - .env
    ports:
      - "${PORT:-3001}:3001"
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

volumes:
  postgres_data:
```

Note: `.env` is referenced as `env_file: - .env` — operators copy `.env.example` to `.env` and fill in values.

**Create `deploy/.env.example`:**

```bash
# TrustEdge Platform Server — Environment Configuration
# Copy this file to deploy/.env and fill in your values.
# Variables without defaults are REQUIRED.
# Variables with defaults are optional — uncomment to override.

# ── Server ──────────────────────────────────────────────────────────────────

# Port the HTTP server listens on.
# Default: 3001
# PORT=3001

# ── PostgreSQL ───────────────────────────────────────────────────────────────
# If DATABASE_URL is not set, the server starts in verify-only mode.
# Stateless endpoints remain available: POST /v1/verify, GET /.well-known/jwks.json, GET /healthz
# Device and receipt endpoints require DATABASE_URL.

# PostgreSQL connection string.
DATABASE_URL=postgres://trustedge:trustedge_dev@postgres:5432/trustedge

# ── JWT / Authentication ─────────────────────────────────────────────────────

# Expected JWT audience claim. Must match the 'aud' field in tokens you issue.
# Default: trustedge-platform
# JWT_AUDIENCE=trustedge-platform
```

Use `#` comments to explain each variable. The DATABASE_URL in the example file should use the docker-compose postgres service hostname (`postgres`), not `localhost`.
  </action>
  <verify>
```bash
ls -la deploy/
grep -n "service_healthy\|platform-server\|postgres" deploy/docker-compose.yml
grep -n "DATABASE_URL\|PORT\|JWT_AUDIENCE" deploy/.env.example
```
All three files exist with the correct content.
  </verify>
  <done>
`deploy/docker-compose.yml` defines `postgres` and `platform-server` services with health-check dependency. `deploy/.env.example` documents PORT, DATABASE_URL, and JWT_AUDIENCE with explanatory comments. Operators can `cp deploy/.env.example deploy/.env` and start the stack.
  </done>
</task>

</tasks>

<verification>
1. `ls deploy/` — shows Dockerfile, docker-compose.yml, .env.example
2. `grep -c "FROM" deploy/Dockerfile` — returns 2 (two FROM stages)
3. `grep "service_healthy" deploy/docker-compose.yml` — present (server waits for postgres)
4. `grep "verify-only" deploy/.env.example` — present (explains DATABASE_URL optional behavior)
5. `grep -n "DATABASE_URL\|PORT\|JWT_AUDIENCE" deploy/.env.example` — all three vars documented
6. `cargo build -p trustedge-platform-server --release 2>&1 | tail -3` — binary still builds (no regression from plan 01)
</verification>

<success_criteria>
- `deploy/` directory contains Dockerfile, docker-compose.yml, and .env.example
- Dockerfile uses multi-stage build (rust builder + debian-slim runtime) with non-root user
- docker-compose.yml starts postgres with health check before platform-server
- .env.example documents all three env vars with explanatory comments
- Verify-only mode clearly explained in .env.example
</success_criteria>

<output>
After completion, create `.planning/phases/28-platform-server-binary/28-02-SUMMARY.md` using the summary template.
</output>
