<!--
Copyright (c) 2025 TRUSTEDGE LABS LLC
MPL-2.0: https://mozilla.org/MPL/2.0/
Project: trustedge — Privacy and trust at the edge.
GitHub: https://github.com/TrustEdge-Labs/trustedge
-->


---
phase: 02-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/src/error.rs
  - crates/core/src/hybrid.rs
  - crates/core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "A unified TrustEdgeError enum exists with subsystem variants"
    - "All subsystem error enums are defined in a single error.rs module"
    - "The name collision with hybrid.rs TrustEdgeError is resolved"
    - "Workspace compiles without errors (no behavior changes yet)"
  artifacts:
    - path: "crates/core/src/error.rs"
      provides: "Unified error hierarchy with TrustEdgeError + all subsystem errors"
      contains: "pub enum TrustEdgeError"
    - path: "crates/core/src/hybrid.rs"
      provides: "Renamed HybridEncryptionError (was TrustEdgeError)"
      contains: "pub enum HybridEncryptionError"
  key_links:
    - from: "crates/core/src/error.rs"
      to: "crates/core/src/lib.rs"
      via: "pub mod error declaration"
      pattern: "pub mod error"
---

<objective>
Create the unified error hierarchy module and resolve the TrustEdgeError name collision.

Purpose: Establish the error.rs module with all subsystem error enums before any migration begins. This is purely additive — no existing code changes behavior, no function signatures change. The hybrid.rs rename eliminates the namespace collision that would block the unified type.

Output: New `crates/core/src/error.rs` with full hierarchy, renamed `HybridEncryptionError` in hybrid.rs, module declared in lib.rs.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-handling/02-RESEARCH.md
@crates/core/src/lib.rs
@crates/core/src/crypto.rs
@crates/core/src/chain.rs
@crates/core/src/asymmetric.rs
@crates/core/src/manifest.rs
@crates/core/src/archive.rs
@crates/core/src/hybrid.rs
@crates/core/src/backends/traits.rs
@crates/core/src/backends/universal.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error.rs with unified error hierarchy</name>
  <files>crates/core/src/error.rs, crates/core/src/lib.rs</files>
  <action>
Create `crates/core/src/error.rs` with the MPL-2.0 copyright header.

Define the following error types using `thiserror::Error`:

1. **TrustEdgeError** — Top-level unified enum with these variants:
   - `Crypto(#[from] CryptoError)` with message "Cryptographic operation failed"
   - `Backend(#[from] BackendError)` with message "Backend operation failed"
   - `Transport(#[from] TransportError)` with message "Transport layer error"
   - `Archive(#[from] ArchiveError)` with message "Archive operation failed"
   - `Manifest(#[from] ManifestError)` with message "Manifest processing error"
   - `Chain(#[from] ChainError)` with message "Chain validation error"
   - `Asymmetric(#[from] AsymmetricError)` with message "Asymmetric crypto error"
   - `Io(#[from] std::io::Error)` with message "IO error: {0}"
   - `Json(#[from] serde_json::Error)` with message "JSON serialization error: {0}"

2. **CryptoError** — Copy existing variants from `crypto.rs` exactly:
   - InvalidKeyFormat(String), InvalidSignatureFormat(String), EncryptionFailed(String), DecryptionFailed(String), SignatureVerificationFailed, KeyGenerationFailed(String), InvalidNonceFormat(String)

3. **ChainError** — Copy existing variants from `chain.rs` exactly:
   - Gap(usize), OutOfOrder { expected: String, found: String }, EndOfChainTruncated

4. **AsymmetricError** — Copy existing variants from `asymmetric.rs` but replace `BackendError(#[from] anyhow::Error)` with `BackendError(String)`:
   - UnsupportedAlgorithm(AsymmetricAlgorithm), InvalidKeyFormat(String), KeyExchangeFailed(String), BackendError(String)
   - Note: The anyhow::Error variant cannot use `#[from]` in a thiserror enum that will be nested. Use String to preserve the message. The `AsymmetricAlgorithm` type must be imported from `crate::backends::AsymmetricAlgorithm`.

5. **ManifestError** — Copy existing variants from `manifest.rs` exactly:
   - Serialization(#[from] serde_json::Error), InvalidField(String)
   - IMPORTANT: serde_json::Error will have `#[from]` on both ManifestError::Serialization and TrustEdgeError::Json. This is fine because they are separate conversion paths. Do NOT add `#[from] serde_json::Error` to ManifestError here — instead use `#[error("Serialization error: {0}")]` with `#[source]` only, because TrustEdgeError already has `#[from] serde_json::Error`. Having two `From<serde_json::Error>` paths (ManifestError -> TrustEdgeError -> from serde_json::Error, AND ManifestError -> from serde_json::Error) causes ambiguity. Use: `Serialization(#[source] serde_json::Error)` without `#[from]`.

   Wait — actually ManifestError::Serialization with `#[from]` is fine because it creates `From<serde_json::Error> for ManifestError`, and TrustEdgeError has `From<serde_json::Error> for TrustEdgeError`. These are on different types, no conflict. The conflict would only arise if both were on TrustEdgeError. Keep `#[from]` on ManifestError::Serialization.

6. **ArchiveError** — Copy existing variants from `archive.rs` but reference error.rs types:
   - Io(#[from] std::io::Error), Manifest(#[from] ManifestError), Json(#[from] serde_json::Error), SchemaMismatch(String), MissingChunk(String), InvalidChunkIndex { expected: usize, found: usize }, SignatureMismatch, Chain(#[from] ChainError), ValidationFailed(String)
   - IMPORTANT: ArchiveError has `#[from] std::io::Error` AND TrustEdgeError has `#[from] std::io::Error`. Same reasoning as ManifestError — these are on different types, so no conflict.

7. **BackendError** — NEW enum:
   - `UnsupportedOperation(String)` — "Backend operation not supported: {0}"
   - `KeyNotFound(String)` — "Key not found: {0}"
   - `InitializationFailed(String)` — "Backend initialization failed: {0}"
   - `HardwareError(String)` — "Hardware backend error: {0}"
   - `OperationFailed(String)` — "Backend operation failed: {0}"

8. **TransportError** — NEW enum:
   - `ConnectionFailed(String)` — "Connection failed: {0}"
   - `SendFailed(String)` — "Send failed: {0}"
   - `ReceiveFailed(String)` — "Receive failed: {0}"
   - `ProtocolError(String)` — "Protocol error: {0}"
   - `Timeout(String)` — "Operation timed out: {0}"
   - `Io(#[from] std::io::Error)` — "IO error: {0}"

   IMPORTANT: TransportError has `#[from] std::io::Error` but so does TrustEdgeError and ArchiveError. Again, different types, no conflict.

Add `pub mod error;` to `crates/core/src/lib.rs` (place it after the existing module declarations, before the layer hierarchy modules). Do NOT add any re-exports from error to the top-level `pub use` section yet — that happens in Plan 03.

All error enums must derive `Debug` (via thiserror). Add `#[derive(Clone)]` only to enums whose variants are all Clone-able (CryptoError, ChainError, ManifestError can have Clone since serde_json::Error does not implement Clone — so only CryptoError and ChainError get Clone).

Add module-level documentation: `//! Unified error hierarchy for the TrustEdge workspace.`
  </action>
  <verify>
Run `cargo build -p trustedge-core` — must compile with no errors. Run `cargo test -p trustedge-core --lib` — all existing tests must pass (error.rs is additive, no behavior changes).
  </verify>
  <done>
`crates/core/src/error.rs` exists with TrustEdgeError enum containing 9 variants (7 subsystem + Io + Json), plus 7 subsystem error enums (CryptoError, ChainError, AsymmetricError, ManifestError, ArchiveError, BackendError, TransportError). Module declared in lib.rs. Workspace compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rename hybrid.rs TrustEdgeError to HybridEncryptionError</name>
  <files>crates/core/src/hybrid.rs, crates/core/src/lib.rs</files>
  <action>
In `crates/core/src/hybrid.rs`:
1. Rename `pub enum TrustEdgeError` to `pub enum HybridEncryptionError`
2. Update ALL references within hybrid.rs: function return types, error construction sites, From impls
3. Search for every function in hybrid.rs that returns `Result<_, TrustEdgeError>` and change to `Result<_, HybridEncryptionError>`

In `crates/core/src/lib.rs`:
1. Find the line `pub use hybrid::{open_envelope, seal_for_recipient, SymmetricKey, TrustEdgeError};`
2. Change `TrustEdgeError` to `HybridEncryptionError` in that re-export line

Search the entire workspace for any imports of `hybrid::TrustEdgeError` or `trustedge_core::TrustEdgeError` and update them. Check:
- `crates/pubky-advanced/` — may import TrustEdgeError from core
- `crates/wasm/` — may reference it
- Any test files

Run `cargo build --workspace` to confirm no compilation errors. If Pubky crates reference the old name, update their imports too.

IMPORTANT: Do NOT add a `From<HybridEncryptionError> for error::TrustEdgeError` conversion yet. That wiring happens in Plan 03 when we update the public API.
  </action>
  <verify>
Run `cargo build --workspace` — must compile. Run `cargo test --workspace` — all 348+ tests must pass. Grep for the old name: `grep -r "hybrid::TrustEdgeError\|pub enum TrustEdgeError" crates/` should return zero results from hybrid.rs (only error.rs should have `pub enum TrustEdgeError`).
  </verify>
  <done>
`hybrid.rs` uses `HybridEncryptionError` everywhere. `lib.rs` re-exports `HybridEncryptionError` instead of `TrustEdgeError`. No compilation errors workspace-wide. The name `TrustEdgeError` is now exclusively owned by `error.rs`.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles without errors
2. `cargo test --workspace` passes all 348+ tests
3. `crates/core/src/error.rs` exists and contains `pub enum TrustEdgeError` with 9 variants
4. `crates/core/src/hybrid.rs` contains `pub enum HybridEncryptionError` (no `TrustEdgeError`)
5. `grep -r "pub enum TrustEdgeError" crates/` returns exactly one match (error.rs only)
</verification>

<success_criteria>
- error.rs module exists with complete error hierarchy (TrustEdgeError + 7 subsystem enums)
- hybrid.rs name collision resolved (HybridEncryptionError)
- Zero test regressions — all 348+ tests pass
- No behavior changes — this plan is purely additive + rename
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling/02-01-SUMMARY.md`
</output>
