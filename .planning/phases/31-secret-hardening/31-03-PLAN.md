---
phase: 31-secret-hardening
plan: 03
type: execute
wave: 3
depends_on:
  - 31-02
files_modified:
  - crates/platform/src/ca/models.rs
  - crates/platform/src/ca/mod.rs
  - crates/platform/src/ca/auth.rs
  - crates/platform/Cargo.toml
  - scripts/ci-check.sh
autonomous: true
requirements:
  - SEC-01
  - SEC-02
  - SEC-04

must_haves:
  truths:
    - "LoginRequest.password is Secret<String> — cannot be printed or serialized by accident"
    - "LoginRequest does not derive Serialize — only Deserialize with custom deserializer for password"
    - "Debug output of LoginRequest shows [REDACTED] for password, not the actual value"
    - "CAConfig.jwt_secret is Secret<String> and redacted in Debug output"
    - "AuthService.jwt_secret is Secret<String> and redacted in Debug output"
    - "CI grep step catches forbidden derive(Serialize) or derive(Debug) regressions on secret-holding structs"
    - "All existing tests pass with no regressions"
  artifacts:
    - path: "crates/platform/src/ca/models.rs"
      provides: "LoginRequest with Secret<String> password, custom Deserialize, no Serialize, manual Debug"
      contains: "Secret"
    - path: "crates/platform/src/ca/mod.rs"
      provides: "CAConfig with Secret<String> jwt_secret, manual Debug"
      contains: "Secret"
    - path: "crates/platform/src/ca/auth.rs"
      provides: "AuthService with Secret<String> jwt_secret"
      contains: "Secret"
    - path: "scripts/ci-check.sh"
      provides: "CI grep check for forbidden derive patterns on secret-holding structs"
      contains: "REDACTED"
  key_links:
    - from: "crates/platform/src/ca/models.rs"
      to: "trustedge-core secret module"
      via: "trustedge_core::Secret"
      pattern: "use trustedge_core::Secret"
    - from: "crates/platform/src/ca/mod.rs"
      to: "trustedge-core secret module"
      via: "trustedge_core::Secret"
      pattern: "use trustedge_core::Secret"
    - from: "scripts/ci-check.sh"
      to: "crates/core/src/backends/yubikey.rs"
      via: "grep for forbidden patterns"
      pattern: "grep.*Serialize.*YubiKeyConfig"
---

<objective>
Harden LoginRequest, CAConfig, and AuthService with Secret<T> wrappers for password and JWT secret fields. Add CI regression check to prevent re-introduction of forbidden derive patterns on secret-holding structs.

Purpose: Closes the last secret-leakage vectors in the platform crate and adds CI enforcement to prevent future regressions. Completes all SEC-* requirements.

Output: Hardened platform models, CI check step in ci-check.sh.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-secret-hardening/31-01-SUMMARY.md
@.planning/phases/31-secret-hardening/31-02-SUMMARY.md
@crates/platform/src/ca/models.rs
@crates/platform/src/ca/mod.rs
@crates/platform/src/ca/auth.rs
@crates/platform/Cargo.toml
@scripts/ci-check.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden LoginRequest, CAConfig, and AuthService with Secret<T></name>
  <files>
    crates/platform/src/ca/models.rs
    crates/platform/src/ca/mod.rs
    crates/platform/src/ca/auth.rs
    crates/platform/Cargo.toml
  </files>
  <action>
**LoginRequest in `crates/platform/src/ca/models.rs`:**

1. Add `use trustedge_core::Secret;` import. (trustedge-core is already a dependency of trustedge-platform.)

2. Change `LoginRequest`:
   - Remove `#[derive(Debug, Serialize, Deserialize)]` entirely
   - Change `pub password: String` to `password: Secret<String>` (private field)
   - Keep `pub email: String` as public
   - Add getter: `pub fn password(&self) -> &str` returning `self.password.expose_secret().as_str()`

3. Implement `fmt::Debug for LoginRequest` manually:
   - Output: `LoginRequest { email: "...", password: [REDACTED] }`

4. Implement `serde::Deserialize for LoginRequest` manually (for receiving HTTP POST bodies):
   - Define a private helper struct `LoginRequestRaw` with `#[derive(Deserialize)]` and `email: String, password: String`
   - In the `Deserialize` impl for `LoginRequest`, deserialize into `LoginRequestRaw` first, then convert: `LoginRequest { email: raw.email, password: Secret::new(raw.password) }`
   - This ensures the password is immediately wrapped in Secret at the deserialization boundary

5. Do NOT implement `Serialize` for `LoginRequest` — this is intentional. Any code path that tries to serialize a LoginRequest should fail at compile time.

6. Add a `LoginRequest::new(email: String, password: String) -> Self` constructor that wraps password in Secret immediately.

**CAConfig in `crates/platform/src/ca/mod.rs`:**

1. Add `use trustedge_core::Secret;` import.

2. Change `CAConfig`:
   - Remove `#[derive(Debug, Clone)]`
   - Change `pub jwt_secret: String` to `jwt_secret: Secret<String>` (private field)
   - Keep other fields public
   - Add `impl Clone for CAConfig` manually (clone the Secret field via `Secret::new(self.jwt_secret.expose_secret().clone())`)

3. Implement `fmt::Debug for CAConfig` manually:
   - Redact `jwt_secret` as `[REDACTED]`, show all other fields normally

4. Add getter: `pub fn jwt_secret(&self) -> &str` returning `self.jwt_secret.expose_secret().as_str()`.

5. Update `Default for CAConfig`: wrap the jwt_secret default value with `Secret::new("your-secret-key".to_string())`.

6. Add builder pattern for CAConfig:
   ```rust
   pub struct CAConfigBuilder { ... }
   impl CAConfig {
       pub fn builder() -> CAConfigBuilder { ... }
   }
   impl CAConfigBuilder {
       pub fn jwt_secret(mut self, secret: String) -> Self { ... }
       pub fn database_url(mut self, url: String) -> Self { ... }
       pub fn ca_name(mut self, name: String) -> Self { ... }
       pub fn ca_organization(mut self, org: String) -> Self { ... }
       pub fn ca_country(mut self, country: String) -> Self { ... }
       pub fn certificate_validity_days(mut self, days: u32) -> Self { ... }
       pub fn build(self) -> CAConfig { ... }
   }
   ```

**AuthService in `crates/platform/src/ca/auth.rs`:**

1. Add `use trustedge_core::Secret;` import.

2. Change `AuthService`:
   - Change `jwt_secret: String` to `jwt_secret: Secret<String>`
   - Update constructor `new(jwt_secret: String)` to wrap: `Self { jwt_secret: Secret::new(jwt_secret) }`
   - Any internal usage of `self.jwt_secret` that needs the raw string should use `self.jwt_secret.expose_secret()`

**LoginResponse in `crates/platform/src/ca/models.rs`:**

3. The `LoginResponse` struct has `pub token: String` — this is a JWT token. Since the token is meant to be serialized in HTTP responses, keep Serialize on LoginResponse. However, note this is a response token, not a stored secret. Leave it as-is per user decision (only wrap fields that hold credentials, keys, and passphrases).

**Verify imports:** Ensure `trustedge_core::Secret` is accessible from the platform crate. Since `trustedge-core` is already in `[dependencies]`, the import `use trustedge_core::Secret;` should work directly.
  </action>
  <verify>
    Run `cargo build -p trustedge-platform` to verify the platform compiles.
    Run `cargo build -p trustedge-platform --features "http,ca"` to verify all feature combos compile.
    Run `cargo test -p trustedge-platform --lib` to verify platform unit tests pass.
    Run `cargo clippy -p trustedge-platform -- -D warnings` to verify no lint issues.
  </verify>
  <done>
    LoginRequest.password is Secret<String> with custom Deserialize and no Serialize. CAConfig.jwt_secret is Secret<String> with redacted Debug. AuthService.jwt_secret is Secret<String>. All compile and pass tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CI grep check for forbidden derive patterns on secret-holding structs</name>
  <files>scripts/ci-check.sh</files>
  <action>
Add a new CI step to `scripts/ci-check.sh` that scans for forbidden derive patterns on known secret-holding structs. This prevents future regressions where someone adds `derive(Debug)` or `derive(Serialize)` back to a struct that holds secrets.

Insert a new step after the existing copyright check step (Step 22 area) and before the final summary. The step should:

1. Define the list of secret-holding struct names: `YubiKeyConfig`, `SoftwareHsmConfig`, `LoginRequest`, `CAConfig`

2. For each struct, grep the corresponding source file for the pattern `#[derive(` on the line immediately before or on the same declaration. Check that:
   - `Serialize` does NOT appear in derives for these structs
   - For `LoginRequest`: `Serialize` does NOT appear (Deserialize is OK since it's custom-implemented)
   - The struct's Debug impl contains `[REDACTED]` (i.e., manual Debug is present)

3. Implementation approach: Use grep to search for lines containing both `derive(` and `Serialize` in the specific files, then check if those lines are associated with the forbidden structs. A simpler approach:
   ```bash
   step "Step NN: Secret struct derive check"
   SECRET_STRUCTS_OK=true

   # Check that secret-holding structs do NOT have derive(Serialize)
   for file_struct in \
       "crates/core/src/backends/yubikey.rs:YubiKeyConfig" \
       "crates/core/src/backends/software_hsm.rs:SoftwareHsmConfig" \
       "crates/platform/src/ca/models.rs:LoginRequest" \
       "crates/platform/src/ca/mod.rs:CAConfig"; do
       FILE="${file_struct%%:*}"
       STRUCT="${file_struct##*:}"

       # Extract 2 lines before struct declaration, look for derive with Serialize
       if grep -B2 "pub struct $STRUCT" "$FILE" | grep -q "Serialize"; then
           fail "$STRUCT in $FILE still has Serialize derive"
           SECRET_STRUCTS_OK=false
       fi
   done

   # Check that secret-holding structs have manual Debug with [REDACTED]
   for file_struct in \
       "crates/core/src/backends/yubikey.rs:YubiKeyConfig" \
       "crates/core/src/backends/software_hsm.rs:SoftwareHsmConfig" \
       "crates/platform/src/ca/models.rs:LoginRequest" \
       "crates/platform/src/ca/mod.rs:CAConfig"; do
       FILE="${file_struct%%:*}"
       STRUCT="${file_struct##*:}"

       if ! grep -q "REDACTED" "$FILE"; then
           fail "$STRUCT in $FILE missing [REDACTED] in Debug impl"
           SECRET_STRUCTS_OK=false
       fi
   done

   if [ "$SECRET_STRUCTS_OK" = true ]; then
       pass "No forbidden derives on secret-holding structs"
   fi
   ```

4. Make the step number sequential with existing steps. Check what the current last step number is and use the next one.

5. Also add verification tests in the test suites that confirm the redaction works at runtime:
   - In `crates/core/src/backends/yubikey.rs` tests (already added in Plan 02)
   - In `crates/core/src/backends/software_hsm.rs` tests (already added in Plan 02)
   - Add a test in `crates/platform/src/ca/models.rs` (add a `#[cfg(test)] mod tests` block):
     - `test_login_request_debug_redacts_password`: Create `LoginRequest::new(...)`, format with `{:?}`, assert contains `[REDACTED]` and does NOT contain the password.
     - `test_login_request_deserialize`: Verify JSON `{"email":"a@b.com","password":"secret"}` deserializes correctly and password is accessible via `.password()`.
  </action>
  <verify>
    Run `./scripts/ci-check.sh` to verify the new step passes.
    Run `cargo test -p trustedge-platform --lib -- ca::models` to verify model tests pass.
    Run `cargo test --workspace` to verify no regressions.
  </verify>
  <done>
    CI grep step added to ci-check.sh that catches forbidden Serialize derives and missing [REDACTED] on YubiKeyConfig, SoftwareHsmConfig, LoginRequest, CAConfig. Platform model tests verify LoginRequest deserialization and Debug redaction at runtime.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` — entire workspace compiles
2. `cargo test --workspace` — all tests pass (265+ tests, no regression)
3. `./scripts/ci-check.sh` — CI check passes including new secret struct step
4. `cargo clippy --workspace -- -D warnings` — no warnings
5. Manual verify: `grep -n "Serialize" crates/platform/src/ca/models.rs` shows no Serialize on LoginRequest
6. Manual verify: `grep -n "Serialize" crates/platform/src/ca/mod.rs` shows no Serialize on CAConfig
</verification>

<success_criteria>
- LoginRequest.password is Secret<String>, deserialized via custom impl, no Serialize
- CAConfig.jwt_secret is Secret<String> with redacted Debug
- AuthService.jwt_secret is Secret<String>
- CI script catches regression if someone adds Serialize or derived Debug back
- Full workspace builds and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-secret-hardening/31-03-SUMMARY.md`
</output>
