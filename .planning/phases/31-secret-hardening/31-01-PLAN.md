---
phase: 31-secret-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/core/Cargo.toml
  - crates/core/src/secret.rs
  - crates/core/src/lib.rs
autonomous: true
requirements:
  - SEC-01
  - SEC-02

must_haves:
  truths:
    - "Secret<T> wraps any value and zeroizes it on drop"
    - "Debug formatting on Secret<T> always outputs [REDACTED], never the inner value"
    - "There is no Display impl on Secret<T> — using {} format is a compile error"
    - "There is no Deref impl — must call expose_secret() to access inner value"
    - "Secret<String> and Secret<Vec<u8>> are the primary usage types"
    - "All existing tests pass after adding the secret module"
  artifacts:
    - path: "crates/core/src/secret.rs"
      provides: "Secret<T> wrapper type with Zeroize, ZeroizeOnDrop, redacted Debug, expose_secret()"
      min_lines: 60
    - path: "crates/core/src/lib.rs"
      provides: "pub mod secret and pub use secret::Secret re-export"
  key_links:
    - from: "crates/core/src/secret.rs"
      to: "zeroize crate"
      via: "Zeroize + ZeroizeOnDrop derive macros"
      pattern: "derive.*Zeroize.*ZeroizeOnDrop"
    - from: "crates/core/src/lib.rs"
      to: "crates/core/src/secret.rs"
      via: "pub mod secret"
      pattern: "pub mod secret"
---

<objective>
Create a reusable `Secret<T>` wrapper type in trustedge-core that provides redacted Debug output, automatic zeroization on drop, and controlled access via `expose_secret()`.

Purpose: This is the foundational type that all secret-hardening in the workspace will use. Following the `secrecy` crate's API convention but implemented in-house since zeroize is already a workspace dependency.

Output: `crates/core/src/secret.rs` module with `Secret<T>` type, re-exported from `trustedge_core::Secret`.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/core/src/lib.rs
@crates/core/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Secret<T> wrapper type with zeroize derive support</name>
  <files>
    Cargo.toml
    crates/core/Cargo.toml
    crates/core/src/secret.rs
    crates/core/src/lib.rs
  </files>
  <action>
1. Update workspace `Cargo.toml`: Change `zeroize = "1.7"` to `zeroize = { version = "1.7", features = ["derive"] }` so the `Zeroize` and `ZeroizeOnDrop` derive macros are available.

2. Update `crates/core/Cargo.toml`: Change `zeroize = "1.7"` to `zeroize = { version = "1.7", features = ["derive"] }` to match.

3. Create `crates/core/src/secret.rs` with the following:
   - Add the standard MPL-2.0 copyright header.
   - Module doc: `//! Secret wrapper type for sensitive values.`
   - `use zeroize::{Zeroize, ZeroizeOnDrop};`
   - `use std::fmt;`
   - Define `Secret<T>` struct: a single-field newtype wrapping `T` where `T: Zeroize`. The struct derives `Zeroize` and `ZeroizeOnDrop` (via zeroize derive macros). Do NOT derive `Debug`, `Clone`, `Serialize`, `Deserialize`, or `Display`.
   - Implement `Secret::new(value: T) -> Self` constructor.
   - Implement `expose_secret(&self) -> &T` method for controlled access.
   - Implement `fmt::Debug for Secret<T>` manually: always write `[REDACTED]` regardless of `T`.
   - Implement `Clone for Secret<T> where T: Clone + Zeroize` manually (clone the inner value into a new Secret).
   - Do NOT implement `Display`, `Deref`, `DerefMut`, `AsRef`, `Serialize`, or `Deserialize`.
   - Add `impl<T: Zeroize + PartialEq> PartialEq for Secret<T>` that delegates to inner values via `expose_secret()`.
   - Add unit tests in a `#[cfg(test)] mod tests` block:
     - `test_debug_redacted`: Create `Secret::new("my-secret".to_string())`, format with `{:?}`, assert output contains `[REDACTED]` and does NOT contain `my-secret`.
     - `test_expose_secret`: Create `Secret::new("value".to_string())`, verify `expose_secret()` returns `"value"`.
     - `test_clone`: Create a Secret, clone it, verify both expose the same inner value.
     - `test_debug_in_struct`: Create a struct with a `Secret<String>` field, derive Debug (manual impl that includes the Secret field), format with `{:?}`, verify `[REDACTED]` appears and the actual secret does not.
     - `test_partial_eq`: Create two Secrets with same value, verify they are equal; create two with different values, verify they are not equal.

4. In `crates/core/src/lib.rs`: Add `pub mod secret;` and add `pub use secret::Secret;` to the top-level re-exports so downstream crates can use `trustedge_core::Secret`.
  </action>
  <verify>
    Run `cargo test -p trustedge-core --lib -- secret` to verify all Secret tests pass.
    Run `cargo build --workspace` to verify no compilation errors.
    Run `cargo clippy -p trustedge-core -- -D warnings` to verify no lint warnings.
  </verify>
  <done>
    Secret<T> type exists at `trustedge_core::Secret` with: redacted Debug output, Zeroize+ZeroizeOnDrop on drop, expose_secret() accessor, no Display/Deref/Serialize, and all 5 unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p trustedge-core --lib -- secret` — all Secret unit tests pass
2. `cargo build --workspace` — no compilation errors
3. `cargo test --workspace` — no test regressions
4. `cargo clippy --workspace -- -D warnings` — no new warnings
</verification>

<success_criteria>
- `Secret<T>` type is usable as `trustedge_core::Secret`
- `format!("{:?}", Secret::new("x".to_string()))` outputs `[REDACTED]`
- No `Display`, `Deref`, `Serialize`, or `Deserialize` impls exist on `Secret<T>`
- `expose_secret()` is the only way to access the inner value
- Zeroize derive feature is enabled in workspace and core Cargo.toml
</success_criteria>

<output>
After completion, create `.planning/phases/31-secret-hardening/31-01-SUMMARY.md`
</output>
