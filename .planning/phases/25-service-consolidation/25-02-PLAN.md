---
phase: 25-service-consolidation
plan: 02
type: execute
wave: 2
depends_on: [25-01]
files_modified:
  - crates/platform/src/lib.rs
  - crates/platform/src/http/mod.rs
  - crates/platform/src/http/handlers.rs
  - crates/platform/src/http/auth.rs
  - crates/platform/src/http/config.rs
  - crates/platform/src/http/state.rs
  - crates/platform/src/http/router.rs
  - crates/platform/src/database/mod.rs
  - crates/platform/src/database/queries.rs
  - crates/platform/src/database/migrations.rs
  - crates/platform/migrations/001_create_multi_tenant_schema.sql
autonomous: true
requirements: [SVC-01, SVC-03]

must_haves:
  truths:
    - "All platform-api endpoints exist in the consolidated crate: POST /v1/verify, POST /v1/devices, GET /v1/receipts/:id, GET /.well-known/jwks.json"
    - "Verify endpoint calls verification logic directly (no HTTP forwarding to verify-core)"
    - "Auth middleware validates Bearer tokens via SHA-256 hash lookup against DB"
    - "Database module provides all CRUD operations for orgs, devices, verifications, receipts"
    - "JWKS endpoint returns keys from the local KeyManager (not proxied)"
    - "Health endpoint returns service status"
  artifacts:
    - path: "crates/platform/src/http/handlers.rs"
      provides: "All HTTP endpoint handlers"
      contains: "verify_handler"
    - path: "crates/platform/src/http/auth.rs"
      provides: "Bearer token auth middleware"
      contains: "auth_middleware"
    - path: "crates/platform/src/database/queries.rs"
      provides: "PostgreSQL CRUD operations"
      contains: "create_device"
    - path: "crates/platform/src/http/router.rs"
      provides: "Axum router composition"
      contains: "create_router"
    - path: "crates/platform/migrations/001_create_multi_tenant_schema.sql"
      provides: "PostgreSQL schema migration"
      contains: "CREATE TABLE organizations"
  key_links:
    - from: "crates/platform/src/http/handlers.rs"
      to: "crates/platform/src/verify/engine.rs"
      via: "direct function call (no HTTP)"
      pattern: "verify::verify_to_report"
    - from: "crates/platform/src/http/handlers.rs"
      to: "crates/platform/src/database/queries.rs"
      via: "sqlx pool"
      pattern: "database::create_verification"
    - from: "crates/platform/src/http/auth.rs"
      to: "crates/platform/src/database/queries.rs"
      via: "token hash lookup"
      pattern: "database::get_org_by_token_hash"
---

<objective>
Build the HTTP layer and database module for trustedge-platform, wiring the verify handler directly to verification core logic.

Purpose: Complete the consolidated crate's REST API surface. The key architectural change is that POST /v1/verify now calls `verify::verify_to_report()` directly instead of forwarding via HTTP to a separate verify-core service. This eliminates the inter-service call and the reqwest dependency.

Output: A feature-complete trustedge-platform library with all endpoints, auth, and database operations.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-service-consolidation/25-CONTEXT.md
@.planning/phases/25-service-consolidation/25-01-SUMMARY.md

# Source repos for HTTP layer and database:
@~/vault/projects/github.com/trustedge-platform-api/platform-api/src/main.rs
@~/vault/projects/github.com/trustedge-platform-api/platform-api/src/handlers.rs
@~/vault/projects/github.com/trustedge-platform-api/platform-api/src/auth.rs
@~/vault/projects/github.com/trustedge-platform-api/platform-api/src/config.rs
@~/vault/projects/github.com/trustedge-platform-api/platform-api/src/database.rs
@~/vault/projects/github.com/trustedge-platform-api/platform-api/src/app_state.rs
@~/vault/projects/github.com/trustedge-platform-api/platform-api/migrations/001_create_multi_tenant_schema.sql
# Verify-service HTTP layer:
@~/vault/projects/github.com/trustedge-verify-core/crates/verify-service/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database module and migrations</name>
  <files>
    crates/platform/src/database/mod.rs
    crates/platform/src/database/queries.rs
    crates/platform/src/database/migrations.rs
    crates/platform/migrations/001_create_multi_tenant_schema.sql
    crates/platform/src/lib.rs
  </files>
  <action>
    **1. Copy the migration SQL file:**
    - Copy `~/vault/projects/github.com/trustedge-platform-api/platform-api/migrations/001_create_multi_tenant_schema.sql` to `crates/platform/migrations/001_create_multi_tenant_schema.sql`
    - This is the exact same schema — preserve as-is per user decision (no database migrations)

    **2. Create `crates/platform/src/database/mod.rs`:**
    - MPL-2.0 copyright header
    - `pub mod queries;`
    - Re-export key functions: `pub use queries::*;`

    **3. Create `crates/platform/src/database/queries.rs`:**
    - Copy all functions from `~/vault/projects/github.com/trustedge-platform-api/platform-api/src/database.rs`
    - Functions: `create_connection_pool`, `run_migrations`, `create_organization`, `create_api_key`, `get_org_by_token_hash`, `create_device`, `get_device`, `create_verification`, `create_receipt`, `get_receipt`
    - These use `sqlx::query()` runtime strings (not compile-time macros) — matches source exactly
    - Update the `sqlx::migrate!()` path in `run_migrations`: use `"./migrations"` which is relative to the crate root (Cargo.toml location), so it should be `"../platform/migrations"` — actually sqlx resolves `./migrations` relative to the crate's Cargo.toml directory by default. So `crates/platform/migrations/` will be found. Keep `sqlx::migrate!("./migrations")`.
    - Update copyright header

    **4. Update `crates/platform/src/lib.rs`:**
    - Change the placeholder `#[cfg(feature = "postgres")] pub mod database;` to point to the real module
    - Ensure the database module is publicly available when postgres feature is enabled
  </action>
  <verify>
    `cargo build -p trustedge-platform --features postgres` succeeds.
    `cargo build -p trustedge-platform` (no features) still succeeds.
    The migration file exists at `crates/platform/migrations/001_create_multi_tenant_schema.sql`.
  </verify>
  <done>
    Database module compiles with postgres feature. All 10 CRUD functions from platform-api are available. Migration SQL is included.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP layer with consolidated router and handlers</name>
  <files>
    crates/platform/src/http/mod.rs
    crates/platform/src/http/handlers.rs
    crates/platform/src/http/auth.rs
    crates/platform/src/http/config.rs
    crates/platform/src/http/state.rs
    crates/platform/src/http/router.rs
    crates/platform/src/lib.rs
    crates/platform/Cargo.toml
  </files>
  <action>
    **1. Create `crates/platform/src/http/mod.rs`:**
    - MPL-2.0 copyright header
    - Declare submodules: `pub mod handlers;`, `pub mod auth;`, `pub mod config;`, `pub mod state;`, `pub mod router;`
    - Re-export key items: `pub use router::create_router;`, `pub use state::AppState;`, `pub use config::Config;`

    **2. Create `crates/platform/src/http/state.rs`:**
    - MPL-2.0 copyright header
    - Unified AppState combining both services:
    ```rust
    use crate::verify::jwks::KeyManager;
    use std::sync::Arc;
    use tokio::sync::RwLock;

    #[derive(Clone)]
    pub struct AppState {
        #[cfg(feature = "postgres")]
        pub db_pool: sqlx::PgPool,
        pub keys: Arc<RwLock<KeyManager>>,
    }
    ```
    - Note: `verify_core_url` is REMOVED — verification is now inline. This is the key consolidation change.

    **3. Create `crates/platform/src/http/config.rs`:**
    - Copy from `~/vault/projects/github.com/trustedge-platform-api/platform-api/src/config.rs`
    - REMOVE `verify_core_url` field (no longer needed — verify-core is inline)
    - Keep: `database_url`, `jwt_audience`, `port`
    - Gate `database_url` field and its env var reading behind `#[cfg(feature = "postgres")]`
    - Update copyright header

    **4. Create `crates/platform/src/http/auth.rs`:**
    - Copy from `~/vault/projects/github.com/trustedge-platform-api/platform-api/src/auth.rs`
    - `OrgContext` struct, `auth_middleware` function, `hash_token`, `generate_token`, `hash_token_for_storage`
    - Update `use crate::database::get_org_by_token_hash;` — gate this import and the middleware behind `#[cfg(feature = "postgres")]`
    - The auth middleware needs sqlx — gate the whole middleware function behind `#[cfg(feature = "postgres")]`
    - Keep `generate_token()` and `hash_token_for_storage()` ungated (pure utility functions)
    - Update copyright header

    **5. Create `crates/platform/src/http/handlers.rs`:**
    This is the critical file — merging platform-api handlers with inline verify-core logic.

    - MPL-2.0 copyright header
    - Gate DB-dependent handlers behind `#[cfg(feature = "postgres")]`

    **Verify handler (the key consolidation):**
    - Instead of forwarding to verify_core_url via reqwest, call `crate::verify::verify_to_report()` directly
    - Instead of parsing JSON response from verify-core, use the VerifyReport directly
    - Still validate segments using `crate::verify::validation::validate_verify_request()` (from verify-service)
    - Still validate empty device_pub and empty manifest (from platform-api)
    - Receipt generation: if `options.return_receipt == true` and both verifications passed, call `crate::verify::receipt_from_report()` then `crate::verify::signing::sign_receipt_jws()` using `state.keys`
    - DB operations: create_verification, create_receipt (gated behind postgres)
    - Return VerifyResponse with verification_id, result, receipt_id

    **Important:** The verify handler signature needs to accommodate both postgres-on and postgres-off modes. Simplest approach: gate the entire verify_handler with DB operations behind `#[cfg(feature = "postgres")]`. Provide a non-postgres verify handler that does verification + receipt but no DB storage.

    Actually, keep it simple per user decision (library only, postgres feature-gated):
    - Provide `verify_handler` that requires the postgres feature (stores to DB)
    - Provide `verify_handler_stateless` that works without postgres (just does verification + optional receipt, no DB storage)
    - Or better: just have one handler with conditional compilation for the DB parts. Use `#[cfg(feature = "postgres")]` blocks inside the function.

    Simplest approach: The handler always does verification inline. DB storage is `#[cfg(feature = "postgres")]` blocks inside. The handler compiles either way.

    But wait — the handler needs `Extension<OrgContext>` from auth middleware which requires postgres. So the handler with auth also requires postgres.

    Final approach: The handlers module exposes two sets:
    1. `#[cfg(feature = "postgres")]` handlers that use auth + DB (the full platform-api behavior)
    2. Stateless handlers (verify, jwks, health) that work without postgres — these match verify-service's original behavior

    **Handlers to implement:**
    - `verify_handler` — Inline verification. `#[cfg(feature = "postgres")]` gates DB write + auth Extension. Without postgres, it's the verify-service style handler.
    - `register_device_handler` — `#[cfg(feature = "postgres")]` only (requires DB)
    - `get_receipt_handler` — `#[cfg(feature = "postgres")]` only (requires DB)
    - `jwks_handler` — Always available (reads from local KeyManager, no proxy)
    - `health_handler` — Always available

    Helper functions from platform-api:
    - `compute_manifest_digest` — Keep, but switch from sha2 to blake3 for consistency (verify-service already uses blake3 for this). Actually, preserve platform-api's sha2 version for DB storage compatibility. The sha2 version is gated behind postgres feature anyway since it's only used for DB storage.

    Helper functions from verify-service:
    - `compute_manifest_digest` (blake3 version) — Used for receipt construction. Keep both: the sha2 one for DB, the blake3 one for receipts. Name them differently: `compute_manifest_digest_sha256` (postgres-gated) and `compute_manifest_digest_blake3`.

    **DeviceRequest, DeviceResponse, ReceiptResponse** types from platform-api handlers.rs — include in handlers.rs, gated behind postgres.

    **`create_test_app`** function from platform-api handlers.rs — include gated behind `#[cfg(any(test, feature = "test-utils"))]` AND `#[cfg(feature = "postgres")]`

    **6. Create `crates/platform/src/http/router.rs`:**
    - Unified router that combines all endpoints
    - `create_router(state: AppState) -> Router`:
      - POST /v1/verify
      - POST /v1/devices (postgres only)
      - GET /v1/receipts/:id (postgres only)
      - GET /.well-known/jwks.json
      - GET /healthz
      - Auth middleware layer (postgres only)
      - CORS layer
      - TraceLayer
    - Use `#[cfg(feature = "postgres")]` for DB-dependent routes and auth middleware

    **7. Update `crates/platform/src/lib.rs`:**
    - Ensure `#[cfg(feature = "http")] pub mod http;` is properly declared

    **8. Update `crates/platform/Cargo.toml` if needed:**
    - Ensure the `http` feature pulls in `postgres` deps transitionally if needed — actually no, keep them independent. `http` provides the web framework, `postgres` provides DB. You can have `http` without `postgres` (stateless verify-only mode).
    - Add `test-utils = []` feature for test app construction

    **9. Verify compilation in all feature combinations:**
    - `cargo build -p trustedge-platform` (no features)
    - `cargo build -p trustedge-platform --features http`
    - `cargo build -p trustedge-platform --features postgres`
    - `cargo build -p trustedge-platform --features "http,postgres"`
    - `cargo build -p trustedge-platform --features "http,postgres,ca"`
  </action>
  <verify>
    `cargo build -p trustedge-platform --features "http,postgres"` succeeds.
    `cargo build -p trustedge-platform --features http` succeeds (stateless mode).
    `cargo build -p trustedge-platform` still succeeds.
    `cargo test -p trustedge-platform --lib` still passes all verify tests.
    `cargo clippy -p trustedge-platform --features "http,postgres" -- -D warnings` passes.
  </verify>
  <done>
    HTTP layer complete: all endpoints registered in router, verify handler calls verification logic directly (no HTTP forwarding), auth middleware validates Bearer tokens, database module handles all CRUD. Feature gates work correctly across all combinations.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p trustedge-platform --features "http,postgres,ca"` — all features compile
2. `cargo build -p trustedge-platform` — default (no features) compiles
3. `cargo build -p trustedge-platform --features http` — stateless mode compiles
4. `cargo test -p trustedge-platform --lib` — unit tests pass
5. Verify no `reqwest` dependency in trustedge-platform (consolidation removes HTTP forwarding)
6. Verify no `verify_core_url` in AppState or Config (removed)
</verification>

<success_criteria>
- All platform-api and verify-service endpoints exist in the consolidated router
- Verify endpoint calls verify_to_report() directly — no HTTP forwarding
- JWKS endpoint serves from local KeyManager — no proxy
- Database module has all 10 CRUD functions
- Migration SQL included
- Feature gates work: http, postgres, ca are independent
- No reqwest dependency in the crate
</success_criteria>

<output>
After completion, create `.planning/phases/25-service-consolidation/25-02-SUMMARY.md`
</output>
