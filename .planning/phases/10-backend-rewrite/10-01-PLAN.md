---
phase: 10-backend-rewrite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/Cargo.toml
  - crates/core/src/backends/yubikey.rs
  - crates/core/src/backends/mod.rs
autonomous: true

must_haves:
  truths:
    - "YubiKeyBackend struct exists with config, lazy hardware connection, and fail-closed error handling"
    - "Backend returns BackendError::HardwareError when hardware unavailable -- never falls back to software"
    - "PIV slot parsing validates 9a/9c/9d/9e and returns clear errors for invalid slots"
    - "ECDSA P-256 and RSA-2048 signing work via PIV slots with pre-hashed digests"
    - "Public key extraction retrieves DER-encoded SPKI from hardware certificate slots"
    - "Slot enumeration detects which PIV slots have keys by reading certificates"
    - "PIN verification enforces max 3 retry limit before returning error"
    - "backend_info() reports available: true only when real hardware session exists"
    - "UniversalBackend trait is fully implemented (perform_operation, supports_operation, get_capabilities, backend_info, list_keys)"
  artifacts:
    - path: "crates/core/Cargo.toml"
      provides: "rcgen dependency added to yubikey feature"
      contains: "rcgen"
    - path: "crates/core/src/backends/yubikey.rs"
      provides: "YubiKey PIV backend implementation"
      min_lines: 350
    - path: "crates/core/src/backends/mod.rs"
      provides: "yubikey module registration"
      contains: "pub mod yubikey"
  key_links:
    - from: "crates/core/src/backends/yubikey.rs"
      to: "crates/core/src/backends/universal.rs"
      via: "impl UniversalBackend for YubiKeyBackend"
      pattern: "impl UniversalBackend for YubiKeyBackend"
    - from: "crates/core/src/backends/yubikey.rs"
      to: "crates/core/src/error.rs"
      via: "BackendError::HardwareError for fail-closed design"
      pattern: "BackendError::HardwareError"
    - from: "crates/core/src/backends/mod.rs"
      to: "crates/core/src/backends/yubikey.rs"
      via: "conditional module compilation"
      pattern: "cfg.*feature.*yubikey"
---

<objective>
Create the YubiKey PIV backend with full UniversalBackend trait implementation, PIV signing operations, public key extraction, slot enumeration, and fail-closed error handling.

Purpose: This is the core backend rewrite -- replacing the deleted 3,263-line broken implementation with a clean, focused ~400-500 line backend using yubikey crate stable API only. Every operation returns BackendError::HardwareError when hardware is unavailable.

Output: Working yubikey.rs backend that compiles with `--features yubikey`, implements all UniversalBackend trait methods, and handles ECDSA P-256 + RSA-2048 signing via PIV slots.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-backend-rewrite/10-RESEARCH.md
@crates/core/src/backends/universal.rs
@crates/core/src/backends/traits.rs
@crates/core/src/backends/mod.rs
@crates/core/src/error.rs
@crates/core/Cargo.toml
@crates/core/src/backends/software_hsm.rs (reference implementation pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rcgen dependency and update yubikey feature flag</name>
  <files>crates/core/Cargo.toml</files>
  <action>
Add `rcgen` as an optional dependency in crates/core/Cargo.toml under the X.509 certificate section:

```toml
rcgen = { version = "0.13", optional = true }
```

Update the `yubikey` feature flag to include rcgen:

```toml
yubikey = ["pkcs11", "dep:yubikey", "x509-cert", "der", "spki", "signature", "rcgen"]
```

Do NOT change any other dependencies. The `pkcs11` dependency stays because it's already declared and used by the feature flag (even though the primary interface uses native yubikey crate PIV API, the feature flag chain requires it).

Verify: `cargo check -p trustedge-core --features yubikey` compiles (may warn about unused deps, that's OK at this stage).
  </action>
  <verify>Run `cargo check -p trustedge-core --features yubikey` -- should compile without errors (warnings OK).</verify>
  <done>rcgen is in Cargo.toml as optional dependency and yubikey feature includes it.</done>
</task>

<task type="auto">
  <name>Task 2: Create YubiKey backend with full UniversalBackend trait implementation</name>
  <files>crates/core/src/backends/yubikey.rs, crates/core/src/backends/mod.rs</files>
  <action>
Create `crates/core/src/backends/yubikey.rs` with the full YubiKey PIV backend. The entire file must be wrapped in `#[cfg(feature = "yubikey")]`. Follow the patterns from software_hsm.rs as reference.

**File structure (in order):**

1. **MPL-2.0 copyright header** (standard Rust header from CLAUDE.md)

2. **Module documentation** -- `//! YubiKey PIV backend for Universal Backend system`

3. **Imports:**
   - `crate::backends::traits::{BackendInfo, KeyMetadata}` for trait returns
   - `crate::backends::universal::*` for CryptoOperation, CryptoResult, BackendCapabilities, etc.
   - `crate::error::BackendError` for error types
   - `serde::{Deserialize, Serialize}` for config
   - `std::collections::HashMap` for key cache
   - `yubikey::YubiKey` and `yubikey::piv::{SlotId, AlgorithmId}` for hardware operations
   - `sha2::{Sha256, Digest}` for pre-hashing (YubiKey signs digests, not raw data)
   - `spki::SubjectPublicKeyInfoRef` and `der::Decode` for public key extraction from certs
   - `der::Encode` for DER serialization

4. **YubiKeyConfig struct:**
   - `pin: Option<String>` -- PIN for PIV operations
   - `default_slot: String` -- default PIV slot (default: "9c" for Signature)
   - `verbose: bool` -- enable verbose logging
   - `max_pin_retries: u8` -- max PIN retries (default: 3)
   - Implement `Default` with default_slot="9c", max_pin_retries=3, verbose=false
   - Derive: Debug, Clone, Serialize, Deserialize

5. **YubiKeyBackend struct:**
   - `config: YubiKeyConfig`
   - `yubikey: Option<yubikey::YubiKey>` -- lazy-initialized hardware connection
   - `pin_retry_count: u8` -- tracks PIN retry attempts within session

6. **YubiKeyBackend methods:**

   a. `pub fn new() -> Result<Self, BackendError>` -- calls with_config(default)

   b. `pub fn with_config(config: YubiKeyConfig) -> Result<Self, BackendError>` -- creates backend, calls connect_if_available()

   c. `fn connect_if_available(&mut self) -> Result<(), BackendError>` -- tries YubiKey::open(), stores on success, logs warning on failure (NOT fatal -- backend_info will report unavailable). Use verbose flag for logging.

   d. `fn ensure_connected(&mut self) -> Result<&mut yubikey::YubiKey, BackendError>` -- returns mutable ref to yubikey or BackendError::HardwareError("YubiKey not connected. Insert device and retry."). This is the fail-closed gate. MUST return `&mut` because yubikey operations require mutable access.

   e. `fn parse_slot(key_id: &str) -> Result<SlotId, BackendError>` -- static method. Maps "9a" -> SlotId::Authentication, "9c" -> SlotId::Signature, "9d" -> SlotId::KeyManagement, "9e" -> SlotId::CardAuthentication. Returns BackendError::KeyNotFound with message listing valid slots for invalid input.

   f. `fn verify_pin(&mut self) -> Result<(), BackendError>` -- checks if PIN is configured, enforces max_pin_retries limit, calls `yubikey::piv::verify_pin()`. On failure, increments pin_retry_count. After max retries, returns BackendError::HardwareError with clear message about lockout risk. Note: Use `yubikey.verify_pin(pin.as_bytes())` from the yubikey crate API.

   g. `fn piv_sign(&mut self, slot: SlotId, data: &[u8], algorithm: &SignatureAlgorithm) -> Result<Vec<u8>, BackendError>` -- Pre-hash data with SHA-256 (YubiKey PIV signs digests, not raw data). Verify PIN first. Then call the yubikey crate's signing function for the slot. Map yubikey errors to BackendError::HardwareError. Support EcdsaP256 (AlgorithmId::EccP256) and RsaPkcs1v15/RsaPss (AlgorithmId::Rsa2048). Return BackendError::UnsupportedOperation for Ed25519 with message "Ed25519 not natively supported by YubiKey PIV. Use ECDSA P-256 for hardware signing."

   h. `fn piv_get_public_key(&mut self, slot: SlotId) -> Result<Vec<u8>, BackendError>` -- Fetch certificate from slot via `yubikey::piv::Certificate::read(&mut self.yubikey, slot)`. Extract SubjectPublicKeyInfo from certificate. Encode as DER bytes using `der::Encode::to_der()`. Return BackendError::KeyNotFound if no certificate in slot.

   i. `fn piv_read_certificate(&mut self, slot: SlotId) -> Result<Vec<u8>, BackendError>` -- Read raw certificate DER from slot. Used for BACK-09.

   j. `fn enumerate_slots(&mut self) -> Result<Vec<(SlotId, String)>, BackendError>` -- Check all 4 PIV slots for certificates. Return list of (slot, description) pairs for populated slots.

7. **Error conversion helper:**
   `fn yubikey_error_to_backend(e: yubikey::Error) -> BackendError` -- Map common yubikey errors to human-readable BackendError messages. Handle NotFound -> "YubiKey not found", AuthenticationError -> "PIN verification failed", GenericError -> pass through, others -> "YubiKey operation failed: {e}".

8. **UniversalBackend implementation for YubiKeyBackend:**

   Note: The UniversalBackend trait uses `&self` but yubikey operations need `&mut self`. Use interior mutability with `std::cell::RefCell` wrapping the `Option<yubikey::YubiKey>` and `pin_retry_count` fields. OR restructure so that:
   - Change `yubikey: Option<YubiKey>` to `yubikey: std::sync::Mutex<Option<YubiKey>>`
   - Change `pin_retry_count: u8` to `pin_retry_count: std::sync::Mutex<u8>`
   - This satisfies the `Send + Sync` requirement of UniversalBackend
   - Lock the mutex in each method that needs mutable access

   a. `perform_operation(&self, key_id: &str, operation: CryptoOperation) -> Result<CryptoResult, BackendError>`:
      - Parse slot from key_id
      - Lock mutex for hardware access
      - Match on operation:
        - Sign { data, algorithm } -> verify_pin, piv_sign, return CryptoResult::Signed
        - GetPublicKey -> piv_get_public_key, return CryptoResult::PublicKey
        - GenerateKeyPair { algorithm } -> map to AlgorithmId, call yubikey generate, return CryptoResult::KeyPair
        - Attest { challenge } -> call attestation, return CryptoResult::AttestationProof
        - Hash operations -> delegate to software (sha2 crate)
        - Everything else -> BackendError::UnsupportedOperation

   b. `supports_operation(&self, operation: &CryptoOperation) -> bool`:
      - Sign with EcdsaP256, RsaPkcs1v15, RsaPss -> true
      - GetPublicKey -> true
      - GenerateKeyPair with EcdsaP256, Rsa2048 -> true
      - Attest -> true
      - Hash with Sha256 -> true
      - Everything else (including Ed25519, symmetric) -> false

   c. `get_capabilities(&self) -> BackendCapabilities`:
      - symmetric_algorithms: empty vec (YubiKey doesn't do symmetric)
      - asymmetric_algorithms: [EcdsaP256, Rsa2048]
      - signature_algorithms: [EcdsaP256, RsaPkcs1v15, RsaPss]
      - hash_algorithms: [Sha256] (software-delegated)
      - hardware_backed: true
      - supports_key_derivation: false
      - supports_key_generation: true
      - supports_attestation: true
      - max_key_size: Some(2048)

   d. `backend_info(&self) -> BackendInfo`:
      - name: "yubikey"
      - description: "YubiKey PIV hardware security backend"
      - version: "1.0.0"
      - available: check if mutex-locked yubikey is Some
      - config_requirements: ["pin (optional)", "default_slot"]

   e. `list_keys(&self) -> Result<Vec<KeyMetadata>, BackendError>`:
      - Lock mutex, ensure connected
      - Enumerate all 4 PIV slots
      - For each slot with certificate, create KeyMetadata with key_id derived from slot hex ("9a", "9c", etc.), description, created_at: 0 (YubiKey doesn't track this)

9. **Module registration in mod.rs:**

   Add to `crates/core/src/backends/mod.rs`:
   - `#[cfg(feature = "yubikey")] pub mod yubikey;` after the existing module declarations
   - `#[cfg(feature = "yubikey")] pub use yubikey::YubiKeyBackend;` in the pub use section

   Do NOT add YubiKey to BackendRegistry::create_backend() or BackendRegistry::list_available_backends() yet -- that integration belongs to a future plan when the backend is fully tested.

**CRITICAL CONSTRAINTS:**
- Zero manual ASN.1/DER encoding. All encoding via der/spki crates only.
- No placeholder keys or signatures anywhere.
- No software fallback code paths. Every crypto operation requires hardware.
- Hash operations (SHA-256) may use software (sha2 crate) since they're not security-critical.
- Ed25519 is NOT supported by YubiKey PIV hardware. Return UnsupportedOperation, not a software fallback.
- All `#[cfg(feature = "yubikey")]` gating on the module level.

**NOTE on Ed25519 (BACK-04):** The research confirms YubiKey PIV does NOT support Ed25519. The requirement BACK-04 specifies "Ed25519 signing works via PIV slot with real hardware key" but this is physically impossible on YubiKey PIV hardware. The implementation should return `BackendError::UnsupportedOperation` with a clear explanation. Add a code comment documenting this hardware limitation. The roadmap success criteria #3 mentions Ed25519 but this is a requirements error -- document the limitation clearly.
  </action>
  <verify>
Run `cargo check -p trustedge-core --features yubikey` -- should compile with zero errors.
Run `cargo clippy -p trustedge-core --features yubikey -- -D warnings` -- should pass with zero warnings.
Verify: `grep -c "BackendError::HardwareError" crates/core/src/backends/yubikey.rs` returns >= 3 (fail-closed gates).
Verify: `grep -c "0x30\|0x02\|push.*tag\|manual.*der\|manual.*asn1" crates/core/src/backends/yubikey.rs` returns 0 (no manual DER).
  </verify>
  <done>
yubikey.rs exists with YubiKeyBackend implementing UniversalBackend trait. Backend compiles with --features yubikey. All PIV operations (sign, get_public_key, generate, attest, list_keys) are implemented. Fail-closed design returns HardwareError when device unavailable. Module registered in mod.rs behind feature gate.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p trustedge-core --features yubikey` compiles
2. `cargo clippy -p trustedge-core --features yubikey -- -D warnings` passes
3. `cargo check -p trustedge-core` (without yubikey feature) still compiles
4. `cargo test --workspace` (without yubikey feature) still passes all existing tests
5. No manual DER encoding in yubikey.rs
6. BackendError::HardwareError used for all hardware-unavailable paths
</verification>

<success_criteria>
- YubiKeyBackend implements full UniversalBackend trait
- Backend uses Mutex<Option<YubiKey>> for thread-safe hardware access
- ECDSA P-256 and RSA-2048 signing with pre-hashed digests
- Public key extraction via certificate SPKI
- PIV slot enumeration for all 4 standard slots
- PIN verification with 3-retry limit
- Ed25519 returns UnsupportedOperation (documented hardware limitation)
- Zero manual ASN.1/DER -- all via der/spki crates
- Fail-closed: every operation gates on ensure_connected()
- Compiles cleanly with --features yubikey
</success_criteria>

<output>
After completion, create `.planning/phases/10-backend-rewrite/10-01-SUMMARY.md`
</output>
