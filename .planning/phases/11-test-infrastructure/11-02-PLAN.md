---
phase: 11-test-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/tests/yubikey_integration.rs
autonomous: true

must_haves:
  truths:
    - "Hardware integration tests require physical YubiKey and are marked #[ignore]"
    - "Real signing operations produce valid non-empty signatures"
    - "Real public key extraction returns DER-encoded SPKI"
    - "Certificate round-trip works: rcgen generate -> x509-cert parse -> public key matches hardware"
    - "Empty hardware slot returns error not placeholder key"
    - "Wrong PIN returns error with clear message"
    - "RSA-2048 signing works via PIV slot"
    - "Every test function contains at least one assert!, assert_eq!, or expect()"
  artifacts:
    - path: "crates/core/tests/yubikey_integration.rs"
      provides: "Hardware integration tests with #[ignore]"
      contains: "#[ignore]"
      min_lines: 150
  key_links:
    - from: "crates/core/tests/yubikey_integration.rs"
      to: "crates/core/src/backends/yubikey.rs"
      via: "use trustedge_core::backends::yubikey::{YubiKeyBackend, YubiKeyConfig}"
      pattern: "YubiKeyBackend"
    - from: "crates/core/tests/yubikey_integration.rs"
      to: "crates/core/src/backends/universal.rs"
      via: "use trustedge_core::backends::universal::{CryptoOperation, CryptoResult, SignatureAlgorithm}"
      pattern: "CryptoOperation"
---

<objective>
Create hardware integration tests for YubiKey backend in a dedicated integration test file, all gated with #[ignore] since they require a physical YubiKey device.

Purpose: These tests verify real hardware operations: signing, key extraction, certificate generation round-trip, and error scenarios with actual YubiKey PIV hardware. They run manually with `cargo test --features yubikey -- --ignored`. Satisfies TEST-02, TEST-03 (hardware), TEST-05, TEST-06 (hardware).

Output: crates/core/tests/yubikey_integration.rs with 8-10 hardware integration tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/11-test-infrastructure/11-RESEARCH.md
@crates/core/src/backends/yubikey.rs
@crates/core/src/backends/universal.rs
@crates/core/src/error.rs
@crates/core/tests/software_hsm_integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hardware integration test file</name>
  <files>crates/core/tests/yubikey_integration.rs</files>
  <action>
Create crates/core/tests/yubikey_integration.rs with the MPL-2.0 copyright header and hardware integration tests. ALL tests MUST be marked with both `#[test]` and `#[ignore = "requires physical YubiKey"]`.

IMPORTANT: This is an integration test file. It can ONLY access public API:
- `YubiKeyBackend::new()`, `YubiKeyBackend::with_config(config)`
- `backend.generate_certificate(slot_id, subject)`
- UniversalBackend trait methods: `perform_operation()`, `supports_operation()`, `get_capabilities()`, `backend_info()`, `list_keys()`
- It CANNOT access private methods like parse_slot, ensure_connected, piv_sign, etc.

The entire file must be feature-gated: add `#![cfg(feature = "yubikey")]` at the top (after copyright header).

**Imports:**
```rust
use trustedge_core::backends::yubikey::{YubiKeyBackend, YubiKeyConfig};
use trustedge_core::backends::universal::{
    CryptoOperation, CryptoResult, SignatureAlgorithm, HashAlgorithm, UniversalBackend,
};
use trustedge_core::error::BackendError;
```

Also import x509-cert and der for certificate round-trip:
```rust
use x509_cert::Certificate;
use der::Decode;
```

NOTE: Check if x509-cert and der are already in dev-dependencies for trustedge-core's Cargo.toml. If not, they need to be added. Check by grepping Cargo.toml for x509-cert/x509_cert. The `der` crate is already a dependency (used in yubikey.rs), and `spki` is too. But `x509-cert` may not be -- check and add to [dev-dependencies] if needed with: `x509-cert = "0.2"`. Use the version that's compatible with the existing `der` and `spki` versions in the workspace.

**Helper function:**
```rust
/// Create a test backend configuration
/// Uses YUBIKEY_TEST_PIN env var or falls back to default "123456"
fn create_test_config() -> YubiKeyConfig {
    let pin = std::env::var("YUBIKEY_TEST_PIN").unwrap_or_else(|_| "123456".to_string());
    YubiKeyConfig {
        pin: Some(pin),
        default_slot: "9c".to_string(),
        verbose: true,
        max_pin_retries: 3,
    }
}

/// Create a backend connected to hardware, panicking with clear message if unavailable
fn create_hardware_backend() -> YubiKeyBackend {
    let config = create_test_config();
    let backend = YubiKeyBackend::with_config(config)
        .expect("Failed to create YubiKey backend. Is a YubiKey inserted?");

    // Verify hardware is actually available
    let info = backend.backend_info();
    assert!(info.available, "YubiKey hardware not detected. Insert device and retry.");

    backend
}
```

**Hardware Signing Tests (TEST-02):**

1. `test_real_ecdsa_p256_signing` - Create hardware backend. Perform Sign operation with data b"Hardware ECDSA P-256 signing test" and SignatureAlgorithm::EcdsaP256 on key_id "9c". Assert Ok result. Match CryptoResult::Signed(signature). Assert signature is not empty. Assert signature length is reasonable for ECDSA P-256 (typically 64-72 bytes DER-encoded, but can vary -- assert len > 32 and len < 128).

2. `test_real_rsa_2048_signing` - Create hardware backend. Perform Sign with SignatureAlgorithm::RsaPkcs1v15 on slot "9c" (or "9a" if that slot has RSA key). Assert result is Ok and signature is non-empty. Note: This test may fail if slot doesn't have an RSA key. Assert signature.len() > 64 (RSA-2048 signatures are 256 bytes).
   IMPORTANT: If the YubiKey slot has an ECDSA key, not RSA, this test will fail. Add a comment explaining this dependency. Consider making this test check supports_operation first and skip gracefully if RSA not available on the slot.

3. `test_real_public_key_extraction` - Create hardware backend. Perform GetPublicKey on slot "9c". Assert Ok result. Match CryptoResult::PublicKey(key_bytes). Assert key_bytes is not empty. Assert key_bytes length is reasonable for DER-encoded SPKI (typically 59-91 bytes for ECDSA P-256 SPKI).

**Key Enumeration Test (TEST-02):**

4. `test_real_slot_enumeration` - Create hardware backend. Call list_keys(). Assert Ok result. The result should contain at least 1 key (since we have a YubiKey with certificates). For each key, assert description is not empty.

**Certificate Round-Trip Test (TEST-05):**

5. `test_certificate_generation_round_trip` - This is the critical TEST-05 test.
   Step 1: Create hardware backend.
   Step 2: Call generate_certificate("9c", "TrustEdge Test Certificate").
   Step 3: Assert Ok, get DER bytes. Assert not empty.
   Step 4: Parse with x509_cert::Certificate::from_der(&cert_der). Assert parsing succeeds.
   Step 5: Extract public key from parsed certificate: cert.tbs_certificate.subject_public_key_info.subject_public_key.raw_bytes().
   Step 6: Get public key from hardware via perform_operation("9c", CryptoOperation::GetPublicKey). Extract the public key bytes from CryptoResult::PublicKey. Parse the SPKI to get raw public key bytes using spki::SubjectPublicKeyInfoRef::try_from().
   Step 7: Assert certificate public key matches hardware public key (assert_eq!).
   Step 8: Verify subject contains "TrustEdge Test Certificate" by checking cert.tbs_certificate.subject.to_string().

**Anti-Pattern Hardware Tests (TEST-03):**

6. `test_hardware_backend_info_reports_available` - Create hardware backend. Call backend_info(). Assert available == true. This proves the "available" flag reflects real hardware state (not hardcoded).

7. `test_ed25519_rejected_by_hardware_backend` - Create hardware backend. Call perform_operation with Sign { data: b"test".to_vec(), algorithm: SignatureAlgorithm::Ed25519 }. Assert is_err(). Assert error matches BackendError::UnsupportedOperation(_). This proves YubiKey PIV correctly rejects unsupported algorithms even when hardware IS present.

**Negative Tests (TEST-06):**

8. `test_wrong_pin_returns_error` - Create backend with WRONG pin (e.g., "000000"). Try to perform a Sign operation. Assert is_err(). Assert error matches BackendError::HardwareError(_). Assert error message contains "PIN" (case-insensitive check via .to_string().to_lowercase().contains("pin")).
   CAUTION: This test consumes a PIN retry. Add comment: "WARNING: This test consumes a PIN retry. Run sparingly to avoid lockout."

9. `test_hash_works_with_hardware_present` - Create hardware backend. Perform Hash { data: b"hardware hash test".to_vec(), algorithm: HashAlgorithm::Sha256 }. Assert Ok and hash is 32 bytes. This verifies hash operations work correctly when hardware IS present (software operation path in hardware backend).

Every test MUST have at least one assert!/assert_eq!/expect() call (TEST-04 compliance).
  </action>
  <verify>
Run: `cargo test -p trustedge-core --features yubikey --test yubikey_integration -- --list` to verify test discovery (should list all test names even though they're ignored).
Run: `cargo check -p trustedge-core --features yubikey --tests` to verify compilation.
Run: `cargo clippy -p trustedge-core --features yubikey --tests -- -D warnings` to verify zero warnings.
Run: `cargo test --workspace` to verify no regression in existing tests.
Grep for "#[ignore" in the file: every test function must have it.
Grep for "assert" in the file: every test function must have at least one assertion.
  </verify>
  <done>
8-10 hardware integration tests exist in crates/core/tests/yubikey_integration.rs. All are gated with #[ignore = "requires physical YubiKey"]. All compile with --features yubikey. All contain assertions. Tests cover: ECDSA P-256 signing, RSA-2048 signing, public key extraction, slot enumeration, certificate round-trip (rcgen -> x509-cert -> public key match), Ed25519 rejection, wrong PIN error, and hash operations. Requirements TEST-02, TEST-03 (hardware), TEST-05, TEST-06 (hardware) satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p trustedge-core --features yubikey --tests` - compiles without errors
2. `cargo clippy -p trustedge-core --features yubikey --tests -- -D warnings` - zero warnings
3. `cargo test --workspace` - existing tests still pass (no regression)
4. `cargo test -p trustedge-core --features yubikey --test yubikey_integration -- --list` - lists all integration test names
5. Every test marked with #[ignore] (grep verification)
6. Every test has at least one assertion (grep verification)
7. x509-cert dependency present in dev-dependencies (if added)
</verification>

<success_criteria>
- 8+ hardware integration tests in yubikey_integration.rs
- All tests marked #[ignore = "requires physical YubiKey"]
- File compiles with --features yubikey
- Zero clippy warnings
- Every test has at least one assertion
- Certificate round-trip test validates: generate -> parse -> public key match
- Anti-pattern tests prove: Ed25519 rejected, wrong PIN fails
- Requirements TEST-02, TEST-03 (hardware), TEST-05, TEST-06 (hardware) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/11-test-infrastructure/11-02-SUMMARY.md`
</output>
