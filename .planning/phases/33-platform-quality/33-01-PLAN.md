---
phase: 33-platform-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/platform/src/verify/validation.rs
  - crates/platform/src/http/handlers.rs
autonomous: true
requirements:
  - PLT-01

must_haves:
  truths:
    - "A single always-compiled validate_verify_request_full() function performs all four verify handler validation checks (empty segments, empty device_pub, empty manifest, hash format)"
    - "A shared build_receipt() function encapsulates receipt construction logic used by both handler variants"
    - "Both cfg(postgres) and cfg(not(postgres)) verify_handler functions call the shared validation and receipt functions with zero duplicated validation logic"
    - "All existing verify integration tests pass without modification"
  artifacts:
    - path: "crates/platform/src/verify/validation.rs"
      provides: "Shared validation function for verify requests and receipt builder"
      exports: ["validate_verify_request_full", "build_receipt_if_requested"]
    - path: "crates/platform/src/http/handlers.rs"
      provides: "Deduplicated verify handler implementations"
      contains: "validate_verify_request_full"
  key_links:
    - from: "crates/platform/src/http/handlers.rs"
      to: "crates/platform/src/verify/validation.rs"
      via: "use crate::verify::validation::validate_verify_request_full"
      pattern: "validate_verify_request_full"
---

<objective>
Deduplicate the verify handler validation and receipt construction logic that is currently copy-pasted between the `cfg(postgres)` and `cfg(not(postgres))` variants of `verify_handler`.

Purpose: Eliminate ~50 lines of duplicated validation code across the two handler variants, making the shared validation logic a single always-compiled public function that downstream crates and integration tests can also call directly.

Output: Refactored `validation.rs` with full validation function, refactored `handlers.rs` with deduplicated handlers.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/platform/src/verify/validation.rs
@crates/platform/src/http/handlers.rs
@crates/platform/src/verify/engine.rs
@crates/platform/src/verify/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared validation and receipt construction functions</name>
  <files>crates/platform/src/verify/validation.rs</files>
  <action>
Add two new public functions to `crates/platform/src/verify/validation.rs`:

1. **`validate_verify_request_full(request: &VerifyRequest) -> Result<(), ValidationError>`** — performs all four validation checks in the same order as the current inline handler code:
   - Empty segments check (error: "invalid_segments", detail: "segments array cannot be empty")
   - Empty device_pub check (error: "invalid_device_pub", detail: "device_pub cannot be empty")
   - Empty/null manifest check (error: "invalid_manifest", detail: "manifest cannot be empty") — check `.is_null()`, empty object, and empty string exactly as the current handlers do
   - Hash format validation via existing `validate_segment_hashes()` call
   - Keep first-error-wins behavior (return on first validation failure, do not collect all errors)

   Note: the existing `validate_verify_request()` function only checks segments and hash format — it does NOT check device_pub or manifest. Keep the old function for backward compatibility but the new `_full` variant is what handlers will use.

2. **`build_receipt_if_requested(request: &VerifyRequest, report: &VerifyReport, state_keys: &KeyManager, manifest_digest_fn: impl Fn(&serde_json::Value) -> String) -> Result<Option<String>, ValidationError>`** — encapsulates the shared receipt construction logic:
   - Check `options.return_receipt == true` AND both `signature_verification.passed` AND `continuity_verification.passed`
   - If conditions met: get device_id from options (default "unknown_device"), compute manifest digest using the provided function, get current kid from KeyManager, call `receipt_from_report()`, sign with `sign_receipt_jws()`, return `Ok(Some(jws))`
   - If conditions not met: return `Ok(None)`
   - On signing failure: return `Err(ValidationError::new("receipt_signing_failed", ...))`
   - The `manifest_digest_fn` parameter allows callers to pass either BLAKE3 (non-postgres) or their own digest function. This avoids the function needing to know about feature flags.

   This function needs `use super::engine::{receipt_from_report, VerifyReport}`, `use super::signing::sign_receipt_jws`, `use super::jwks::KeyManager`, and `use super::types::VerifyRequest`.

   Since `sign_receipt_jws` is async, `build_receipt_if_requested` must also be async.

Add tests for `validate_verify_request_full`:
- Test that empty segments returns "invalid_segments" error
- Test that empty device_pub returns "invalid_device_pub" error
- Test that null/empty manifest returns "invalid_manifest" error
- Test that a valid request with proper segments passes validation
- Test validation order: a request with BOTH empty segments AND empty device_pub returns "invalid_segments" (first check wins)
  </action>
  <verify>
Run `cargo test -p trustedge-platform --lib` — all existing validation tests pass, plus the new tests for `validate_verify_request_full`.
Run `cargo build -p trustedge-platform --features http` — compiles without errors.
Run `cargo build -p trustedge-platform --features "http,postgres"` — compiles without errors.
  </verify>
  <done>
`validate_verify_request_full` exists as a public function in validation.rs, covers all 4 validation checks, has unit tests, and compiles under all feature flag combinations.
`build_receipt_if_requested` exists as a public async function in validation.rs and encapsulates receipt construction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor verify handlers to use shared functions</name>
  <files>crates/platform/src/http/handlers.rs</files>
  <action>
Refactor both `verify_handler` variants in `crates/platform/src/http/handlers.rs` to call the shared functions:

1. **Replace inline validation** in both `cfg(not(postgres))` and `cfg(postgres)` handlers:
   - Remove the 4 inline validation blocks (empty segments, empty device_pub, empty manifest, hash format)
   - Replace with a single call: `validate_verify_request_full(&request).map_err(|e| (StatusCode::BAD_REQUEST, Json(e)))?;`
   - Update the import to include `validate_verify_request_full` from `crate::verify::validation`

2. **Replace inline receipt construction** in both handler variants:
   - In `cfg(not(postgres))` handler: replace the receipt construction block (lines ~125-160) with a call to `build_receipt_if_requested(&request, &report, &*state.keys.read().await, compute_manifest_digest_blake3)`. Map the error to `(StatusCode::INTERNAL_SERVER_ERROR, Json(e))`.
   - In `cfg(postgres)` handler: the receipt construction is more complex because it also stores to DB. Keep the DB storage inline but use `build_receipt_if_requested` for the receipt object construction and signing. Alternatively, since the postgres handler also needs to store the receipt and capture the receipt_id, it may be cleaner to keep the receipt construction inline for postgres but still use the shared `build_receipt_if_requested` for the common parts.

   **Decision**: For the postgres handler, the receipt construction interleaves with DB storage (create_receipt call). To keep it simple and avoid over-abstracting, only extract the receipt construction for the non-postgres handler. For the postgres handler, at minimum remove the duplicated validation (the bigger win). The receipt construction in the postgres handler can remain inline since it has DB-specific logic interleaved. Document this with a comment: `// Receipt construction inlined here due to DB storage interleaving`.

3. **Ensure the `compute_manifest_digest_blake3` helper** remains available (it's a private function in handlers.rs — keep it as-is, or make it `pub(crate)` if needed by validation.rs).

4. Do NOT change any response types, status codes, or error message strings — the API contract must remain identical.
  </action>
  <verify>
Run `cargo test -p trustedge-platform --lib` — all tests pass (including handlers tests if any).
Run `cargo test -p trustedge-platform --test verify_integration --features http` — all 7 integration tests pass.
Run `cargo build -p trustedge-platform --features "http,postgres"` — compiles without errors.
Run `cargo clippy -p trustedge-platform --features "http,postgres" -- -D warnings` — no warnings.
Manually inspect handlers.rs: confirm the 4 inline validation blocks (empty segments, empty device_pub, empty manifest, hash format) no longer exist in either handler variant. They should be replaced by a single `validate_verify_request_full` call.
  </verify>
  <done>
Both verify_handler variants call `validate_verify_request_full()` instead of duplicating validation logic inline. The non-postgres handler uses the shared receipt builder. No duplicated validation branches exist in handlers.rs. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p trustedge-platform --lib` — all unit tests pass
2. `cargo test -p trustedge-platform --test verify_integration --features http` — all integration tests pass
3. `cargo build -p trustedge-platform --features http` — non-postgres build compiles
4. `cargo build -p trustedge-platform --features "http,postgres"` — full build compiles
5. `cargo clippy -p trustedge-platform --features "http,postgres" -- -D warnings` — zero warnings
6. grep handlers.rs for duplicated validation: the strings "segments array cannot be empty", "device_pub cannot be empty", "manifest cannot be empty" should each appear exactly 0 times in handlers.rs (moved to validation.rs)
</verification>

<success_criteria>
- `validate_verify_request_full` is a public function that performs all 4 validation checks
- Both handler variants call the shared validation function
- No duplicated validation logic in handlers.rs
- All existing tests pass without modification
- API contract unchanged (same status codes, error messages, response shapes)
</success_criteria>

<output>
After completion, create `.planning/phases/33-platform-quality/33-01-SUMMARY.md`
</output>
