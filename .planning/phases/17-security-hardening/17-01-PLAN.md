---
phase: 17-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
  - scripts/ci-check.sh
  - Cargo.toml
  - Cargo.lock
autonomous: true

must_haves:
  truths:
    - "Running cargo audit against the workspace produces no actionable vulnerabilities"
    - "Any advisories that cannot be fixed are documented with explicit risk acceptance"
    - "CI pipeline runs cargo audit as a blocking check on every push and PR"
    - "Local ci-check.sh mirrors the CI cargo audit step"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "cargo-audit blocking CI step"
      contains: "cargo audit"
    - path: "scripts/ci-check.sh"
      provides: "Local cargo-audit check step"
      contains: "cargo audit"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "Cargo.lock"
      via: "cargo audit reads lock file for vulnerability scanning"
      pattern: "cargo.audit|cargo-audit"
    - from: "scripts/ci-check.sh"
      to: "Cargo.lock"
      via: "cargo audit reads lock file for vulnerability scanning"
      pattern: "cargo.audit|cargo-audit"
---

<objective>
Run cargo-audit against the workspace to identify any known vulnerabilities in the dependency tree, fix or document all advisories, then integrate cargo-audit as a blocking check in both CI and the local ci-check.sh script.

Purpose: Ensure the dependency tree has no known security vulnerabilities, and that this invariant is enforced on every future change.
Output: Clean cargo-audit report, CI and local script updated with blocking audit step.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.github/workflows/ci.yml
@scripts/ci-check.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install cargo-audit, run audit, and resolve all advisories</name>
  <files>Cargo.toml, Cargo.lock</files>
  <action>
    1. Install cargo-audit: `cargo install cargo-audit --locked`
    2. Run `cargo audit` against the workspace from the project root
    3. Analyze the output:
       - If CLEAN (no vulnerabilities): Document the clean result and proceed
       - If vulnerabilities found:
         a. For each advisory, check if a version bump of the affected dependency resolves it
         b. Apply version bumps in the workspace Cargo.toml (or crate-level Cargo.toml if not workspace-managed)
         c. After bumps, run `cargo update` for affected packages and re-run `cargo audit`
         d. If any advisory CANNOT be fixed (no patched version exists, or upgrading breaks compatibility):
            - Document it with: advisory ID, affected crate, severity, why it cannot be fixed, risk acceptance rationale
         e. Repeat until `cargo audit` is clean OR all remaining advisories are documented
    4. Verify the workspace still builds and tests pass:
       - `cargo build --workspace --no-default-features`
       - `cargo test --workspace --lib --no-default-features`
    5. If version bumps were needed, verify clippy still passes:
       - `cargo clippy --workspace --no-default-features -- -D warnings`

    Note: If cargo-audit requires a deny.toml for ignoring specific advisories that have no fix available, create it at the project root with clear comments explaining each ignore entry. Use `[advisories]` ignore list format.
  </action>
  <verify>
    - `cargo audit` exits with code 0 (clean) OR all remaining advisories are in deny.toml with documented rationale
    - `cargo build --workspace --no-default-features` succeeds
    - `cargo test --workspace --lib --no-default-features` succeeds
  </verify>
  <done>
    The dependency tree has no unaddressed security vulnerabilities. Either cargo-audit reports clean, or every remaining advisory has explicit risk acceptance documentation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cargo-audit to CI pipeline and local ci-check.sh</name>
  <files>.github/workflows/ci.yml, scripts/ci-check.sh</files>
  <action>
    1. Update `.github/workflows/ci.yml`:
       - In the "Install analysis tools" step, add: `cargo install cargo-audit --locked`
       - Add a new step AFTER the "Install analysis tools" step and BEFORE the "Copyright headers" step (run audit early to fail fast):
         ```yaml
         - name: Security audit (cargo-audit)
           run: cargo audit
         ```
       - This step must NOT have `continue-on-error: true` -- it is a blocking check
       - If a deny.toml was created in Task 1, cargo-audit will automatically use it

    2. Update `scripts/ci-check.sh`:
       - Add a new step between Step 1 (Copyright headers) and Step 2 (Format check)
       - Renumber subsequent steps accordingly (old Step 2 becomes Step 3, etc.)
       - The new step:
         ```bash
         # -- Step 2: Security audit --
         step "Step 2: Security audit (cargo-audit)"
         if command -v cargo-audit &> /dev/null; then
             if cargo audit; then
                 pass "cargo audit"
             else
                 fail "cargo audit â€” run: cargo audit to see details"
             fi
         else
             skip "cargo-audit not installed (install: cargo install cargo-audit)"
         fi
         ```
       - Use the same pattern as cargo-hack/cargo-semver-checks: skip gracefully if not installed, but fail if installed and finds issues
       - Update ALL step numbers in comments and echo strings to be sequential after insertion

    3. Verify both files are syntactically valid:
       - `bash -n scripts/ci-check.sh` (syntax check)
       - Visually confirm ci.yml is valid YAML (proper indentation)
  </action>
  <verify>
    - `bash -n scripts/ci-check.sh` exits 0 (valid bash syntax)
    - `.github/workflows/ci.yml` contains "cargo audit" step without continue-on-error
    - `scripts/ci-check.sh` contains "cargo audit" step with graceful skip if not installed
    - Step numbers in ci-check.sh are sequential with no gaps or duplicates
  </verify>
  <done>
    CI pipeline runs cargo-audit as a blocking check on every push/PR. Local ci-check.sh includes cargo-audit with graceful degradation if the tool is not installed locally.
  </done>
</task>

</tasks>

<verification>
1. `cargo audit` exits 0 (or all advisories are documented with risk acceptance)
2. `cargo build --workspace --no-default-features` succeeds
3. `cargo test --workspace --lib --no-default-features` succeeds
4. `.github/workflows/ci.yml` has a non-continue-on-error cargo-audit step
5. `scripts/ci-check.sh` has a cargo-audit step that skips gracefully if tool not installed
6. `bash -n scripts/ci-check.sh` exits 0
7. Step numbers in ci-check.sh are sequential
</verification>

<success_criteria>
- cargo-audit reports no known vulnerabilities (or all exceptions documented)
- CI blocks on any new vulnerability introduced in future PRs
- Local developer workflow includes security audit check
- No regressions in build, test, or clippy
</success_criteria>

<output>
After completion, create `.planning/phases/17-security-hardening/17-01-SUMMARY.md`
</output>
