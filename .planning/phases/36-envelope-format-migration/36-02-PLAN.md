---
phase: 36-envelope-format-migration
plan: 02
type: execute
wave: 2
depends_on: [36-01]
files_modified:
  - crates/core/src/envelope.rs
autonomous: true
requirements: [VER-02, TST-01, TST-02]

must_haves:
  truths:
    - "Decrypting a v2 envelope with the correct recipient key returns the original plaintext"
    - "Decrypting a v1 (legacy per-chunk salt) envelope succeeds via try-then-fallback without modifying stored data"
    - "All 8 existing envelope tests pass without regression"
    - "A new multi-chunk round-trip test encrypts and decrypts a multi-chunk payload using the v2 format"
    - "A dedicated v1 legacy fallback test constructs a v1-format envelope and verifies the fallback decrypt path returns correct plaintext"
  artifacts:
    - path: "crates/core/src/envelope.rs"
      provides: "v2 decrypt path + v1 fallback + comprehensive test suite"
      contains: "fn decrypt_chunk_v2"
  key_links:
    - from: "Envelope::unseal"
      to: "decrypt_chunk_v2 / decrypt_chunk_v1"
      via: "try v2 first, if decryption error fall back to v1"
      pattern: "decrypt_chunk_v2.*decrypt_chunk_v1"
    - from: "decrypt_chunk_v2"
      to: "derive_shared_encryption_key"
      via: "uses envelope-level hkdf_salt (called once, nonce reconstructed from prefix + index)"
      pattern: "hkdf_salt"
---

<objective>
Implement backward-compatible decryption supporting both v1 and v2 envelope formats, and update the test suite.

Purpose: Complete the format migration by adding a v2 decrypt path (HKDF-once + deterministic nonce reconstruction) and preserving the v1 decrypt path (per-chunk salt + random nonce) for backward compatibility. Validate with all existing tests plus a new multi-chunk v2 round-trip test.

Output: Fully working envelope.rs with seal (v2 only) and unseal (v2-first, v1 fallback) paths. All tests pass.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-envelope-format-migration/36-01-SUMMARY.md
@crates/core/src/envelope.rs
@crates/core/src/format.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement v2 decrypt and v1 fallback in unseal path</name>
  <files>crates/core/src/envelope.rs</files>
  <action>
  Implement the dual-version decryption path:

  **1. Create `decrypt_chunk_v2()` method:**
  - Signature: `fn decrypt_chunk_v2(&self, chunk: &NetworkChunk, encryption_key: &[u8; 32], nonce_prefix: &[u8; 8], is_last_chunk: bool) -> Result<Vec<u8>>`
  - NOTE: Do NOT pass `decryption_key: &SigningKey` — the raw signing key is not used inside this method (key material is pre-derived). Including it would trigger `cargo clippy -- -D warnings` failure.
  - Reconstruct the deterministic nonce: `nonce_prefix` (8 bytes) || `chunk.sequence as u32` big-endian bytes [1..4] (3 bytes) || last_flag (1 byte: 0xFF if is_last_chunk, else 0x00)
  - Deserialize the signed manifest and chunk manifest from `chunk.manifest` (same as existing decrypt)
  - Recreate AAD using `build_aad()` with `blake3::hash(b"ENVELOPE_V1")` as header_hash, the chunk's sequence, the reconstructed nonce, the manifest hash, and `manifest.chunk_size`
  - Decrypt using AES-256-GCM with the provided `encryption_key` and reconstructed nonce
  - Return plaintext

  **2. Preserve existing `decrypt_chunk()` as `decrypt_chunk_v1()`:**
  - Rename the existing `decrypt_chunk` method to `decrypt_chunk_v1`
  - This method keeps its current behavior: reads `key_derivation_salt` from ChunkManifest, calls `derive_shared_encryption_key` with that per-chunk salt, uses the nonce stored on the NetworkChunk
  - The derive_shared_encryption_key signature changed in Plan 01 (3 params now), so update the call accordingly — pass `&manifest.key_derivation_salt` as salt. The v1 path derives per-chunk, so it calls derive inside the method for each chunk. Only use the encryption_key (first element of returned tuple), ignore the nonce_prefix since v1 uses the stored random nonce.

  **3. Rewrite `unseal()` with try-then-fallback:**
  - After verification passes, attempt v2 decryption first (expected common case):
    - Call `derive_shared_encryption_key(decryption_key, &sender_public_key, &self.hkdf_salt)` once
    - Sort chunks by sequence
    - For each chunk: call `decrypt_chunk_v2(chunk, &encryption_key, &nonce_prefix, is_last)` where `is_last = (i == sorted_chunks.len() - 1)`
    - If ANY chunk decryption fails, fall back to v1 path
  - V1 fallback path:
    - Sort chunks by sequence (reuse sorted_chunks)
    - For each chunk: call `decrypt_chunk_v1(chunk, decryption_key)`
    - If v1 also fails, return the v1 error (more informative for truly corrupt data)
  - Zeroize the v2 encryption key after use (whether v2 succeeded or fell back to v1)
  - This try-then-fallback approach is more resilient than checking the version field, per user decision

  **4. Verify payload size** after successful decryption (keep existing check).
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/trustedge && cargo test -p trustedge-core --lib -- envelope --nocapture 2>&1 | tail -30</automated>
    <manual>unseal() tries v2 first then falls back to v1; all 8 existing envelope tests pass</manual>
  </verify>
  <done>unseal() implements try-v2-then-fallback-v1 decryption; decrypt_chunk_v2 reconstructs deterministic nonces; decrypt_chunk_v1 preserves per-chunk salt derivation; all existing tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add v2 multi-chunk round-trip test and version field assertions</name>
  <files>crates/core/src/envelope.rs</files>
  <action>
  Add new tests to the existing `#[cfg(test)] mod tests` block:

  **1. `test_v2_multi_chunk_roundtrip()`:**
  - Create a payload larger than DEFAULT_CHUNK_SIZE (e.g., `DEFAULT_CHUNK_SIZE * 3 + 500` bytes of patterned data)
  - Seal with `Envelope::seal()`
  - Assert `envelope.version == 2` (verify new field is set)
  - Assert `envelope.hkdf_salt != [0u8; 32]` (salt was generated)
  - Assert `envelope.metadata.chunk_count == 4`
  - Verify envelope
  - Unseal with beneficiary key
  - Assert plaintext == original payload byte-for-byte

  **2. `test_v2_single_chunk_roundtrip()`:**
  - Small payload (< DEFAULT_CHUNK_SIZE)
  - Seal, assert version == 2, unseal, assert roundtrip

  **3. `test_v2_envelope_version_field()`:**
  - Seal a payload
  - Assert `envelope.version == 2`
  - Serialize to JSON with `serde_json::to_string()`
  - Assert the JSON contains `"version":2`
  - Deserialize back
  - Assert version is preserved

  **4. `test_v2_deterministic_nonces_are_unique()`:**
  - Seal a multi-chunk payload (at least 3 chunks)
  - Collect all nonces from `envelope.chunks`
  - Assert all nonces are distinct (deterministic counter produces unique nonces)
  - Assert nonces are NOT random (check that nonces share the same 8-byte prefix)

  **5. `test_v1_legacy_fallback()`:**
  - This test exercises the v1 fallback path to ensure backward-compatibility (VER-02) is not just claimed but verified.
  - Construct a v1-style envelope by manually building it: seal a payload normally (which produces v2), then mutate the envelope to simulate v1 format:
    - Set `envelope.version = 1`
    - Set `envelope.hkdf_salt = [0u8; 32]`
    - For each chunk: re-encrypt the chunk data using the v1 per-chunk path — call `derive_shared_encryption_key` with a fresh random per-chunk salt, use a random 12-byte nonce, encrypt with AES-256-GCM, update the chunk's manifest with the per-chunk `key_derivation_salt` and a nonzero `pbkdf2_iterations` value (use 1 for test speed), and store the random nonce on the NetworkChunk
  - Alternatively (simpler approach): if the original v1 `seal()` code is still available as a test helper or can be extracted, use it directly to produce a genuine v1 envelope. If not, the manual construction approach above ensures the v1 decrypt_chunk_v1 code path is exercised.
  - Call `unseal()` on this v1-format envelope with the correct recipient key
  - Assert the plaintext matches the original payload byte-for-byte
  - This proves the try-then-fallback logic actually reaches and succeeds via the v1 branch (v2 decryption will fail on these chunks, triggering the fallback)

  Make the `version`, `hkdf_salt`, and `chunks` fields accessible in tests. Since tests are in the same module (`mod tests` inside envelope.rs), private fields are already accessible.

  Run `cargo test -p trustedge-core --lib` and verify all tests pass (existing + new).
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/trustedge && cargo test -p trustedge-core --lib -- envelope --nocapture 2>&1 | tail -40</automated>
    <manual>13+ envelope tests pass (8 existing + 5 new); v2 multi-chunk roundtrip demonstrates correct HKDF-once + deterministic nonce behavior; v1 legacy fallback test proves backward-compat path is exercised</manual>
  </verify>
  <done>5 new tests added: v2 multi-chunk roundtrip, v2 single-chunk roundtrip, version field serialization, deterministic nonce uniqueness, v1 legacy fallback. All envelope tests pass. TST-01 (no regression) and TST-02 (multi-chunk v2 end-to-end) requirements met. VER-02 backward-compat tested via actual v1 fallback path execution</done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo test -p trustedge-core --lib` passes with zero failures
2. All 8 existing envelope tests pass (TST-01 no regression)
3. New `test_v2_multi_chunk_roundtrip` passes: seal v2 -> unseal -> byte-for-byte match (TST-02)
4. Try-then-fallback decryption handles both v2 and v1 envelopes (VER-02)
5. New `test_v1_legacy_fallback` passes: manually constructed v1 envelope decrypts via fallback path (VER-02 verified)
6. `cargo clippy -p trustedge-core -- -D warnings` passes (decrypt_chunk_v2 has no unused parameters)
</verification>

<success_criteria>
- unseal() decrypts v2 envelopes via HKDF-once + deterministic nonce reconstruction
- unseal() decrypts v1 envelopes via per-chunk salt fallback (backward compat)
- All existing 8 envelope tests pass without modification (TST-01)
- New multi-chunk v2 round-trip test passes (TST-02)
- New v1 legacy fallback test passes: constructs a v1-format envelope and verifies unseal() reaches the fallback path
- VER-02 requirement fully addressed and tested
- `cargo test -p trustedge-core --lib` and `cargo clippy` clean
</success_criteria>

<output>
After completion, create `.planning/phases/36-envelope-format-migration/36-02-SUMMARY.md`
</output>
