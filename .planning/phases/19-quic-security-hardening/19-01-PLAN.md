---
phase: 19-quic-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/core/Cargo.toml
  - crates/core/src/transport/quic.rs
  - Cargo.toml
  - Cargo.lock
  - .github/workflows/ci.yml
  - scripts/ci-check.sh
autonomous: true

must_haves:
  truths:
    - "Default QUIC build uses proper TLS certificate verification via system/webpki root certificates"
    - "SkipServerVerification struct only exists when insecure-tls feature is enabled"
    - "create_client_endpoint() uses proper TLS roots by default, falls back to SkipServerVerification only with insecure-tls feature"
    - "CI validates that default build compiles and clippy-checks with the insecure-tls feature flag"
    - "Developer-facing doc comments clearly warn that insecure-tls is development-only"
  artifacts:
    - path: "crates/core/Cargo.toml"
      provides: "insecure-tls feature flag definition"
      contains: "insecure-tls"
    - path: "crates/core/src/transport/quic.rs"
      provides: "Secure QUIC TLS by default, feature-gated insecure path"
      contains: "webpki_roots"
    - path: ".github/workflows/ci.yml"
      provides: "CI step for insecure-tls feature validation"
      contains: "insecure-tls"
    - path: "scripts/ci-check.sh"
      provides: "Local CI step for insecure-tls feature validation"
      contains: "insecure-tls"
  key_links:
    - from: "crates/core/src/transport/quic.rs"
      to: "crates/core/Cargo.toml"
      via: "cfg(feature = insecure-tls) conditional compilation"
      pattern: "cfg.*feature.*insecure.tls"
    - from: "crates/core/src/transport/quic.rs"
      to: "webpki_roots crate"
      via: "TLS root store for proper certificate verification"
      pattern: "webpki_roots::TLS_SERVER_ROOTS"
---

<objective>
Secure QUIC TLS by default and gate insecure certificate skipping behind an opt-in feature flag.

Purpose: The QUIC client currently uses `SkipServerVerification` unconditionally in its default `connect()` path, accepting any TLS certificate without validation. This is a critical security gap — a MITM attacker could intercept all QUIC traffic. This plan makes proper TLS the default and gates the insecure path behind `insecure-tls` for development use only.

Output: Secure-by-default QUIC transport, feature-gated insecure path, CI validation, updated tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/core/src/transport/quic.rs
@crates/core/Cargo.toml
@Cargo.toml
@.github/workflows/ci.yml
@scripts/ci-check.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add insecure-tls feature flag and refactor QUIC TLS to secure-by-default</name>
  <files>
    crates/core/Cargo.toml
    Cargo.toml
    Cargo.lock
    crates/core/src/transport/quic.rs
  </files>
  <action>
1. Add `webpki-roots = "0.26"` to `crates/core/Cargo.toml` under `[dependencies]` (next to the existing `rustls` dependency). This provides Mozilla's trusted root certificate store for proper TLS verification.

2. Add `insecure-tls` feature flag to `crates/core/Cargo.toml` under `[features]`:
   ```
   insecure-tls = []  # Development only: skip TLS certificate verification in QUIC
   ```
   No new dependencies needed for the feature flag itself — it just gates conditional compilation.

3. Refactor `crates/core/src/transport/quic.rs`:

   a. Add conditional import at top of file:
      ```rust
      use rustls::RootCertStore;
      ```

   b. Refactor `create_client_endpoint()` to have TWO paths:
      - **Default path (no feature flag):** Build a `rustls::ClientConfig` using `webpki_roots::TLS_SERVER_ROOTS` as the trust store. Use `ClientConfig::builder().with_root_certificates(root_store).with_no_client_auth()`. This provides proper TLS verification.
      - **Insecure path (`#[cfg(feature = "insecure-tls")]`):** Keep the existing `SkipServerVerification` behavior behind `cfg(feature = "insecure-tls")`.

      The function should look like:
      ```rust
      fn create_client_endpoint() -> Result<Endpoint> {
          let crypto = Self::build_client_tls_config()?;
          let client_config = quinn::ClientConfig::new(Arc::new(
              quinn::crypto::rustls::QuicClientConfig::try_from(crypto)?,
          ));
          let mut endpoint = Endpoint::client("0.0.0.0:0".parse()?)?;
          endpoint.set_default_client_config(client_config);
          Ok(endpoint)
      }

      /// Build TLS client configuration.
      /// Default: proper certificate verification using Mozilla root certificates.
      /// With `insecure-tls` feature: skips certificate verification (DEVELOPMENT ONLY).
      fn build_client_tls_config() -> Result<rustls::ClientConfig> {
          #[cfg(not(feature = "insecure-tls"))]
          {
              let mut root_store = RootCertStore::empty();
              root_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());
              Ok(rustls::ClientConfig::builder()
                  .with_root_certificates(root_store)
                  .with_no_client_auth())
          }
          #[cfg(feature = "insecure-tls")]
          {
              // WARNING: This disables TLS certificate verification.
              // Only use for local development and testing.
              // Never enable insecure-tls in production builds.
              Ok(rustls::ClientConfig::builder()
                  .dangerous()
                  .with_custom_certificate_verifier(Arc::new(SkipServerVerification))
                  .with_no_client_auth())
          }
      }
      ```

   c. Gate `SkipServerVerification` struct and its `impl` block behind `#[cfg(feature = "insecure-tls")]`. This ensures the insecure code literally does not exist in default builds.

   d. Add a doc comment to the `insecure-tls` gated section:
      ```rust
      /// WARNING: Insecure TLS certificate verifier that accepts ALL certificates.
      /// This exists ONLY for local development and testing.
      /// NEVER enable the `insecure-tls` feature in production builds.
      /// To use: `cargo build --features insecure-tls`
      ```

   e. The `HardwareBackedVerifier` is a separate path (used by `connect_with_hardware_verification`, not by the default `Transport::connect`). Leave it as-is — it uses its own trust model (trusted certificate list), which is a legitimate verification approach, not insecure skipping.

4. Run `cargo build -p trustedge-core --no-default-features` and `cargo build -p trustedge-core --features insecure-tls` to verify both paths compile.

5. Run `cargo test -p trustedge-core --no-default-features` to verify existing tests pass. The existing tests only test config creation and don't use the TLS path, so they should pass unchanged.
  </action>
  <verify>
    - `cargo build -p trustedge-core --no-default-features` succeeds (secure default)
    - `cargo build -p trustedge-core --features insecure-tls` succeeds (insecure dev path)
    - `cargo clippy -p trustedge-core --all-targets --no-default-features -- -D warnings` passes
    - `cargo clippy -p trustedge-core --all-targets --features insecure-tls -- -D warnings` passes
    - `cargo test -p trustedge-core --no-default-features` passes
    - `grep -c 'SkipServerVerification' crates/core/src/transport/quic.rs` shows the struct is wrapped in `#[cfg(feature = "insecure-tls")]`
    - `grep 'webpki_roots' crates/core/src/transport/quic.rs` shows proper root store usage in default path
  </verify>
  <done>
    Default QUIC build uses Mozilla root certificates for TLS verification. SkipServerVerification only exists when insecure-tls feature is enabled. Both build paths compile and pass clippy. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CI validation for insecure-tls feature and add compile-time test</name>
  <files>
    .github/workflows/ci.yml
    scripts/ci-check.sh
    crates/core/src/transport/quic.rs
  </files>
  <action>
1. Add a test to `crates/core/src/transport/quic.rs` in the existing `#[cfg(test)] mod tests` block that verifies the default TLS configuration is secure:

   ```rust
   #[test]
   fn test_default_build_uses_secure_tls() {
       // Verify that in the default build (no insecure-tls feature),
       // create_client_endpoint produces an endpoint with proper TLS config.
       // This test passes if the code compiles without insecure-tls,
       // proving SkipServerVerification is not used by default.
       let endpoint = QuicTransport::create_client_endpoint();
       assert!(endpoint.is_ok(), "Default client endpoint creation should succeed with proper TLS roots");
   }
   ```

   Add a conditional test that confirms the insecure path is available when the feature is active:
   ```rust
   #[cfg(feature = "insecure-tls")]
   #[test]
   fn test_insecure_tls_feature_available() {
       // This test only compiles when insecure-tls is enabled,
       // verifying the feature flag gates the insecure path correctly.
       let endpoint = QuicTransport::create_client_endpoint();
       assert!(endpoint.is_ok(), "Insecure TLS endpoint creation should succeed");
   }
   ```

2. Add CI step to `.github/workflows/ci.yml` after the existing `clippy (trustedge-core with keyring)` step:

   ```yaml
   - name: clippy (trustedge-core with insecure-tls)
     run: cargo clippy --package trustedge-core --all-targets --features insecure-tls -- -D warnings

   - name: tests (trustedge-core with insecure-tls)
     run: cargo test --package trustedge-core --features insecure-tls --locked --verbose
   ```

   This ensures the insecure-tls feature doesn't bitrot (same pattern as yubikey, git-attestation, keyring feature validation).

3. Add a matching local CI step to `scripts/ci-check.sh` after the keyring step (Step 8) and before the feature powerset step (Step 9). Renumber subsequent steps. Add:

   ```bash
   # -- Step 9: Clippy (insecure-tls) ───────────────────────────────
   step "Step 9: Clippy (trustedge-core with insecure-tls)"
   if cargo clippy --package trustedge-core --all-targets --features insecure-tls -- -D warnings; then
       pass "clippy insecure-tls"
   else
       fail "clippy insecure-tls"
   fi
   ```

   Renumber existing steps 9-19 to 10-20.

4. Run `cargo test -p trustedge-core --no-default-features` to verify the default test passes.
5. Run `cargo test -p trustedge-core --features insecure-tls` to verify the feature-gated test passes.
  </action>
  <verify>
    - `cargo test -p trustedge-core test_default_build_uses_secure_tls --no-default-features -- --nocapture` passes
    - `cargo test -p trustedge-core test_insecure_tls_feature_available --features insecure-tls -- --nocapture` passes
    - `.github/workflows/ci.yml` contains `insecure-tls` step
    - `scripts/ci-check.sh` contains `insecure-tls` step
    - `grep -c 'insecure-tls' .github/workflows/ci.yml` returns at least 2 (clippy + test steps)
    - `grep -c 'insecure-tls' scripts/ci-check.sh` returns at least 1
  </verify>
  <done>
    CI validates insecure-tls feature on every PR. Default test proves secure TLS is used without the feature. Feature-gated test proves insecure path works when opted in. Local ci-check.sh mirrors CI behavior.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p trustedge-core --no-default-features` -- default build succeeds with secure TLS
2. `cargo build -p trustedge-core --features insecure-tls` -- insecure dev build succeeds
3. `cargo test -p trustedge-core --no-default-features` -- all tests pass with secure defaults
4. `cargo test -p trustedge-core --features insecure-tls` -- feature-gated tests pass
5. `cargo clippy -p trustedge-core --no-default-features -- -D warnings` -- zero warnings in secure build
6. `cargo clippy -p trustedge-core --features insecure-tls -- -D warnings` -- zero warnings in insecure build
7. `grep -c 'cfg.*feature.*insecure.tls' crates/core/src/transport/quic.rs` -- confirms conditional compilation gating
8. Verify `SkipServerVerification` does NOT exist in default build by checking it is behind cfg gate
</verification>

<success_criteria>
- QUIC-01: QUIC client uses proper TLS certificate verification by default (webpki_roots trust store)
- QUIC-02: Insecure TLS skip is gated behind insecure-tls feature flag
- CI validates both default and insecure-tls builds on every PR
- Developer documentation (doc comments) warns about insecure-tls being development-only
- All existing tests continue to pass
- cargo-hack feature powerset still passes (insecure-tls is a simple feature with no deps)
</success_criteria>

<output>
After completion, create `.planning/phases/19-quic-security-hardening/19-01-SUMMARY.md`
</output>
